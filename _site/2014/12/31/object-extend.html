<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>javascript 对象继承</title>
   <meta name="author" content="tudousi" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
</head>
<body>


<div class="site">
  <div class="title">
    <a class="extra" href="/">HOME</a>
    <a class="" href="/javascript.html">JAVASCRIPT</a>
    <a class="" href="/htmlcss.html">HTML/CSS</a>
    <a class="" href="/tools.html">开发工具</a>
    <a class="" href="/plugin.html">JS/JQ插件</a>
  </div>
  
  <div id="post">
<h1>javascript 对象继承</h1>
<div class="copyright">
	作者: 蒋著 | 可以转载, 但必须以超链接形式标明文章原始出处和作者信息及版权声明<br />
	网址: http://createthink.net/2014/12/31/object-extend.html
	</div>
<h3>JavaScript 对象基础和概念</h3>

<blockquote><p>JavaScript 是基于原型的面向对象语言，并不像 JAVA、C++ 这种基于对象的语言。如果要理解 JavaScript 中的对象，理解原型 (prototype) 和构造函数 (constructor) 是非常重要的。</p></blockquote>

<ul>
<li>构造函数 (constructor)</li>
<li>原型对象 (prototype)</li>
</ul>


<p>JavaScript 中的构造函数不同于其他基于对象的语言，它是一个函数，比如： function Class(){} 这就是构造函数，可以看下 js 中的构造函数和其他语言的构造函数的区别</p>

<pre><code class="javascript">// javascript
function Person(){}
</code></pre>

<pre><code class="java">// java
class Person {
    public Person(){}
}
</code></pre>

<pre><code class="c++">// c++
class Person {
    public:
        Person(){}
}
</code></pre>

<pre><code class="php">// php
class Person {
    function __construct(){}
}
</code></pre>

<p>好了扯得有点远，js 中的构造函数 (constructor) 是用来初始化对象的。</p>

<p>所有的构造函 (constructor) 数都有一个 prototype 属性，它就是原型。js 就是靠他实现继承的。</p>

<p>我们现在把构造函数拿来分析下:<br>
<img src="/resource/javascript-extend/javascript-extend-1.png" /></p>

<ul>
<li>编号 1 就是每个构造函数的原型(prototype)</li>
<li>编号 2 每个原型中都有一个属性 construct(构造函数)</li>
<li>编号 3 只要是对象实例就会有一个 __proto__ 属性它指向构造函数所继承的原型的引用(prototype)。</li>
</ul>


<h4>原型链 (prototype chain)</h4>

<p>__proto__ 是原型链实现的关键，每个对象实例都包含一个 __proto__ 属性，它指向构造函数 (constructor) 属性的引用。<br>
<img src="/resource/javascript-extend/javascript-extend-2.png" /></p>

<p>下面的代码证明了 p 的对象实例属性 __proto__ 是指向构造函数 Person 的原型 (prototype)</p>

<pre><code class="javascript">function Person(){}
var p = new Person();
console.log(p.__proto__ === Person.prototype);  // true
</code></pre>

<h4>函数 (function) 对象的原型链</h4>

<p>在JavaScript中，函数（function）是一个特殊的对象，所有函数都是构造函数Function的实例，所以，函数的原型链与new操作符实例化对象的原型链会不同，先看下面代码：</p>

<pre><code class="javascript">function Person() {}
alert(Person.__proto__ === Object.prototype); // false
alert(Person.__proto__ === Function.prototype); // true
</code></pre>

<p>在 js 中函数 (function) 是一个特殊的对象，所有的函数 (function) 都是构造函数 (Function) 的实例。</p>

<p>对于上面的 Person 函数现在来看下它的原型链是怎么样的</p>

<p>Person -> __proto__ -> Function.prototype -> __proto__ -> Object.prototype -> __proto__ -> null</p>

<p>javascript 对象结构图<br>
<img src="/resource/javascript-extend/javascript-extend-3.png" /></p>

<h4>javascript 对象实例</h4>

<ul>
<li>一个基本类
这里的 this 指向的是 new 出来的对象实例，所以构造函数会给对象实例添加一系列初始化的属性</li>
</ul>


<pre><code class="javascript">// 版本1 构造函数初始化属性
function Person(name, age){
    this.name = name;
    this.age = age;
    this.talk = function(){
        console.log('hello my name is:' + this.name);
    };
}
var td = new Person('tudou', 22);
td.talk();
// 版本2 在原型是添加属性和方法
function Person(name, age){
    this.name = name;
    this.age = age;
}
Person.prototype.talk = function(){
    console.log('hello my name is:' + this.name);
};
var td = new Person('tudou', 22);
td.talk();
</code></pre>

<p>基本类讲完了，来看下在 js 中如何实现继承的，看下面代码：</p>

<pre><code class="javascript">function Person(name, age){
    this.name = name;
    this.age = age;
    console.log('Person constructor');
}
Person.prototype.talk = function(){
    console.log('hello my name is:' + this.name);
};
function Programmer(){
    // 调用父类构造函数来初始化 Programmer 的属性
    Person.apply(this, arguments);
    console.log('Programmer constructor');
}
// 简单粗暴的把 Programmer 对象的原型属性指向 Person 的原型
Programmer.prototype = Person.prototype;
Programmer.prototype.talk = function(){
    console.log('i age is:' + this.age);
};
var p = new Person('tudou', 22);
var td = new Programmer('tudou', 22);
p.talk();   // i age is:22
td.talk();  // i age is:22
</code></pre>

<p>上面代码是一种暴力继承，这样做不是最佳方法，作为一个君子，此方法不可用。有一个坏处：Programmer.talk 会覆盖 Person.talk。</p>

<p>针对上面的优化继承方案</p>

<pre><code class="javascript">// 原型继承修改为
Programmer.prototype = new Person();
</code></pre>

<p>这样做的好处就是 Programmer.prototype 继承的是一个 Person 对象的实例，修改 Programmer.prototype 并不会影响到 Perons</p>

<pre><code class="javascript">// 优化继承
function Person(name, age){
    this.name = name;
    this.age = age;
    console.log('Person constructor');
}
Person.prototype.talk = function(){
    console.log('hello my name is:' + this.name);
};
function Programmer(){
    // 调用父类构造函数来初始化 Programmer 的属性
    Person.apply(this, arguments);
    console.log('Programmer constructor');
}
// 优化原型继承
Programmer.prototype = new Person();
Programmer.prototype.talk = function(){
    console.log('i age is:' + this.age);
};
var p = new Person('tudou', 22);
var td = new Programmer('tudou', 22);
p.talk();   // hello my name is:tudou
td.talk();  // i age is:22
</code></pre>

<p>下面的继承其实没有什么问题，但是给 Programmer.prototype 赋值的时候会实例化 Person ，如果我们只想继承 Perons.prototype 就的使用一个空的对象作为代理，在把 Programmer.prototype 指向这个代理对象</p>

<pre><code class="javascript">function Person(){
    console.log('Person constructor');
}
Person.prototype.talk = function(){
    console.log('hello my name is tudou');
};
function Programmer(){
    console.log('Programmer constructor');
}
// 再次优化继承
function Empey(){}
Empey.prototype = Person.prototype;
Programmer.prototype = new Empey();
Programmer.prototype.talk = function(){
    console.log('i age is 22');
};
var p = new Person();
var td = new Programmer();
p.talk();
td.talk();
</code></pre>

<p>通过 Empty 这一层对象实例作为了中转，在修改 Programmer.prototype 的属性的时候就不会影响到 Person.prototype 了</p>

<p>未完待续。。。</p>

</div>

<div id="related">
  <h2>最近文章</h2>
  <ul class="posts">
    
      <li><span>29 Dec 2014</span> &raquo; <a href="/2014/12/29/iframe-by-value.html">页面中多 iframe 传值</a></li>
    
      <li><span>26 Dec 2014</span> &raquo; <a href="/2014/12/26/svn-command.html">SVN 命令介绍</a></li>
    
      <li><span>13 Dec 2014</span> &raquo; <a href="/2014/12/13/connect-using-the-analytical.html">Connect 中间件使用解析</a></li>
    
  </ul>
</div>
  
  <div class="footer"></div>
<div class="power">  
  Powered by <a href="http://github.com/" targe="_blank">Github</a> &nbsp;&amp;&amp;&nbsp; <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> 
</div>
</div>

<a href="https://github.com/tudousi"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a>

<!-- Google Analytics end -->

</body>
</html>
