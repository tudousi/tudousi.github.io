<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>javascript面向对象 &#8211; 再试，再失败，更好地失败</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="从面向对象特点、javascript 如何面向对象、各种面向对象实现分析、面向对象的组件设计四个方面来看javascript 面向对象编程">
    <meta name="author" content="tudousi">
    <meta name="keywords" content="javascript oo">
    <link rel="canonical" href="http://tudousi.github.io//javascript/2015/11/22/javascript-oo/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for 再试，再失败，更好地失败" href="/feed.xml" />
    <meta name="baidu-site-verification" content="3865RHLBYn" />
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?201603180323" type="text/css">

    <!-- Fonts -->
    <!--
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    -->
    

    <!-- Verifications -->
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="javascript面向对象">
    <meta property="og:description" content="一个菜鸟的前端学习历程 html css javascript node node.js">
    <meta property="og:url" content="http://tudousi.github.io//javascript/2015/11/22/javascript-oo/">
    <meta property="og:site_name" content="再试，再失败，更好地失败">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
    <meta name="twitter:title" content="javascript面向对象" />
    <meta name="twitter:description" content="从面向对象特点、javascript 如何面向对象、各种面向对象实现分析、面向对象的组件设计四个方面来看javascript 面向对象编程" />
    <meta name="twitter:url" content="http://tudousi.github.io//javascript/2015/11/22/javascript-oo/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

    
</head>

<body class="site">
  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://tudousi.github.io/" class="site-title">再试，再失败，更好地失败</a>
      <nav class="site-nav">
        <a href="/mtb/">MTB</a>
<a href="/about/">About</a>
<a href="/contact/">Contact</a>

      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>javascript面向对象</h1>
  <span class="post-meta">2015-11-22</span><br>
  
  <span class="post-meta small">
  
    10 minute read
  
  </span>
</div>

<article class="post-content">
  <p>开头要啥bb的话。土豆不是装逼之人，也不反对装逼，但是逼乎不要太过分了。以前的<a href="http://createthink.net/javascript/2014/12/31/object-extend/">文章</a>有点老了内容涵盖也挺少的就重新写一篇吧。</p>

<blockquote>
  <p>我是不懂面向对象编程，我也不懂原型链，我只是切图的。那我这个切图的就出来说说javascript oo 这些事吧</p>
</blockquote>

<p>所涵盖内容：</p>

<p>1、面向对象特点</p>

<p>2、javascript 如何面向对象</p>

<p>3、各种面向对象实现分析</p>

<p>4、面向对象的组件设计</p>

<div style="background:#ccc;height:2px;margin:10px;0;text-align:center;"></div>

<h3 id="section">1、面向对象特点：</h3>
<p>抽象、继承、封装、多态，面向对象的特性大家应该都知道，思想很明显一切都是对象的思想来编程，对象有自己的方法和属性，对象也有扩展的方法（接口），面向对象前3中特性在javascript中都适用，
唯独多态性在javascript是比较蹩脚的，但是也可以实现。关于面向对象的文章太多太多了，总之面向对象编程就是用生活中习惯的方式写出计算机所能识别的代码。</p>

<h3 id="javascript-">2、javascript 如何面向对象</h3>

<p>内容较多啊，建议泡杯咖啡、茶或者其他什么的边喝边看，我也选了一首节奏感比较强的歌，也可以边听歌边看</p>
<embed src="http://www.xiami.com/widget/0_1771155385/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent" />

<p>先从基础开始说起，那就是对象在javascript所存在的形态，它有2种存在的形态。1：对象字面量创建的对象 2、构造函数所创建的对象。看下面代码就知道了</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 1对象字面量形态</span>
<span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// 2构造函数形态</span>
<span class="kd">function</span> <span class="nx">Obj2</span><span class="p">()</span> <span class="p">{}</span>
<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Obj2</span><span class="p">();</span>
<span class="c1">// 创建对象完毕后，就可以给对象添加属性和方法了。</span>
<span class="nx">obj1</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'tudou'</span><span class="p">;</span>
<span class="nx">obj1</span><span class="p">.</span><span class="nx">speak</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"it's fuck oo"</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">obj1</span><span class="p">.</span><span class="nx">speak</span><span class="p">();</span></code></pre></figure>

<p>上面的例子只是javascript中对象的书写形式，但是对象方法或者属性是具有继承性的，比如你继承你父亲的财产肯定要比你自己去赚取来的快且方便。下面就来看看javascript如何继承以及各个框架或者库是如何实现继承的吧。</p>

<h3 id="section-1">3、各种面向对象实现分析</h3>

<p>javascript实现继承最核心的就是原型链继承，知道了原型链继承后，其他的继承也就比较好理解。</p>

<p>先来创建一个电脑的类，根据这个电脑类可以派生出不同类型的电脑对象。然后根据这个例子来分析原型链继承。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/**
* Computer	电脑类，它有构造函数用于创建电脑的基本信息，还有电脑的基本通用方法。比如执行命令、获取品牌名称、获取内存大小等
* brand 	电脑品牌
* ram 		内存
* cpu 		cpu型号
* disk 		硬盘大小
****/</span>
<span class="kd">function</span> <span class="nx">Computer</span><span class="p">(</span><span class="nx">brand</span><span class="p">,</span> <span class="nx">ram</span><span class="p">,</span> <span class="nx">cpu</span><span class="p">,</span> <span class="nx">disk</span><span class="p">){</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">brand</span> <span class="o">=</span> <span class="nx">brand</span><span class="p">;</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">ram</span> <span class="o">=</span> <span class="nx">ram</span><span class="p">;</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">cpu</span> <span class="o">=</span> <span class="nx">cpu</span><span class="p">;</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">disk</span> <span class="o">=</span> <span class="nx">disk</span><span class="p">;</span>
	<span class="c1">// 执行命令</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">runCommand</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span>
	<span class="p">};</span>
	<span class="c1">// 返回品牌名称</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">getBrand</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">brand</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="c1">// 返回内存大小</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">getRam</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">ram</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'你好，欢迎使用'</span> <span class="o">+</span> <span class="nx">brand</span> <span class="o">+</span> <span class="s1">'电脑'</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 给用户推送消息</span>
<span class="nx">Computer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">msg</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 创建一台联想电脑</span>
<span class="kd">var</span> <span class="nx">computer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Computer</span><span class="p">(</span><span class="s1">'lenovo'</span><span class="p">,</span> <span class="s1">'8'</span><span class="p">,</span> <span class="s1">'i7'</span><span class="p">,</span> <span class="s1">'250'</span><span class="p">);</span>
<span class="nx">computer</span><span class="p">.</span><span class="nx">msg</span><span class="p">(</span><span class="s1">'你的内存大小为：'</span> <span class="o">+</span> <span class="nx">computer</span><span class="p">.</span><span class="nx">getRam</span><span class="p">()</span> <span class="o">+</span> <span class="s1">'G'</span><span class="p">);</span>
<span class="cm">/***
---console.log---
// 你的内存大小为：8G
// 你好，欢迎使用lenovo电脑
****/</span></code></pre></figure>

<p>大家注意到了吗？上面的getBrand和getRam方法我写在了Computer的构造函数中，而msg我是写在了原型链中。</p>

<blockquote>
  <p>什么是原型链：每个函数都有一个对象属性prototype(原型)，对象的继承原理可以理解成就是一个一个prototype(原型)串联起来的。
所以大家也就叫原型链了吧。prototype有3个基本属性：1、constructor指向函数的构造函数。 2、__proto__指向该函数的父级prototype。 3、用户自定义的属性</p>
</blockquote>

<p>来观察一下computer这个类所创建出来的对象在浏览器中是什么样子的。</p>

<p><img src="/resource/javascriptoo/1.png" alt="javascriptoo" /></p>

<p>恩，大家应该注意到了吧，只有绿色箭头的msg函数没有在computer对象的实例中，它是存在了Computer函数的prototype属性中。</p>

<p>恩，上面的代码是面向对象了，也有很好的封装性，但是万一有天我需要创建dell、acer、hp等电脑该怎么办？不可能都在这个一个类里添加修改类方法吧。所以需要基于这个Computer类来创建不同品牌的电脑类。</p>

<p>下面修改下代码不直接使用基类Computer来创建联想电脑，而是基于继承机制，重新创建一个专属于联想的电脑类，代码如下</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="cm">/**
* Computer	电脑类，它有构造函数用于创建电脑的基本信息，还有电脑的基本通用方法。比如执行命令、获取品牌名称、获取内存大小等
* brand 	电脑品牌
* ram 		内存
* cpu 		cpu型号
* disk 		硬盘大小
****/</span>
<span class="kd">function</span> <span class="nx">Computer</span><span class="p">(</span><span class="nx">brand</span><span class="p">,</span> <span class="nx">ram</span><span class="p">,</span> <span class="nx">cpu</span><span class="p">,</span> <span class="nx">disk</span><span class="p">){</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">brand</span> <span class="o">=</span> <span class="nx">brand</span><span class="p">;</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">ram</span> <span class="o">=</span> <span class="nx">ram</span><span class="p">;</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">cpu</span> <span class="o">=</span> <span class="nx">cpu</span><span class="p">;</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">disk</span> <span class="o">=</span> <span class="nx">disk</span><span class="p">;</span>
	<span class="c1">// 执行命令</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">runCommand</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span>
	<span class="p">};</span>
	<span class="c1">// 返回品牌名称</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">getBrand</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">brand</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="c1">// 返回内存大小</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">getRam</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">ram</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'你好，欢迎使用'</span> <span class="o">+</span> <span class="nx">brand</span> <span class="o">+</span> <span class="s1">'电脑'</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 给用户推送消息</span>
<span class="nx">Computer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">msg</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 创建一台联想电脑</span>
<span class="c1">// 现在我需要一台联想电脑，那么不需要自己重新开始创建电脑的所以属性和方法，只需要继承Computer就行了</span>
<span class="kd">function</span> <span class="nx">Lenovo</span><span class="p">(</span><span class="nx">ram</span><span class="p">,</span> <span class="nx">cpu</span><span class="p">,</span> <span class="nx">disk</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">Computer</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s1">'lenovo'</span><span class="p">,</span> <span class="nx">ram</span><span class="p">,</span> <span class="nx">cpu</span><span class="p">,</span> <span class="nx">disk</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">Lenovo</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Computer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">lenovo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Lenovo</span><span class="p">(</span><span class="s1">'8'</span><span class="p">,</span> <span class="s1">'i7'</span><span class="p">,</span> <span class="s1">'500'</span><span class="p">);</span>
<span class="nx">lenovo</span><span class="p">.</span><span class="nx">msg</span><span class="p">(</span><span class="s1">'你的内存大小为：'</span> <span class="o">+</span> <span class="nx">lenovo</span><span class="p">.</span><span class="nx">getRam</span><span class="p">()</span> <span class="o">+</span> <span class="s1">'G'</span><span class="p">);</span></code></pre></figure>

<p>在前面这个例子中Lenovo类实现了继承Computer类。当你创建Lenovo对象实例后去调用Lenovo对象不存在的方法时，他会根据原型链一直向上查找直到原型链为null为止。如下图</p>

<p>因为 Lenovo.prototype = Computer.prototype 这句代码，让Lenovo的原型链指向了Computer的原型链，所以它们才有了继承关系。</p>

<p><img src="/resource/javascriptoo/2.png" alt="javascriptoo" /></p>

<p>关于继承的好坏或者是否调用构造函数继承等可以去看以前的<a href="http://createthink.net/javascript/2014/12/31/object-extend/">文章</a></p>

<p>现在我们来看下各种库或者框架是如何实现继承的，那些优点和缺点。</p>

<p>首先来看看js大神John Resig的<a href="http://ejohn.org/blog/simple-javascript-inheritance/">继承</a>方法，用john的继承方法重写的电脑类</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Computer</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
	<span class="na">init</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">brand</span><span class="p">,</span> <span class="nx">ram</span><span class="p">,</span> <span class="nx">cpu</span><span class="p">,</span> <span class="nx">disk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">brand</span> <span class="o">=</span> <span class="nx">brand</span><span class="p">;</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">ram</span> <span class="o">=</span> <span class="nx">ram</span><span class="p">;</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">cpu</span> <span class="o">=</span> <span class="nx">cpu</span><span class="p">;</span>
		<span class="k">this</span><span class="p">.</span><span class="nx">disk</span> <span class="o">=</span> <span class="nx">disk</span><span class="p">;</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'你好，欢迎使用'</span> <span class="o">+</span> <span class="nx">brand</span> <span class="o">+</span> <span class="s1">'电脑'</span><span class="p">);</span>
	<span class="p">},</span>
	<span class="c1">// 执行命令</span>
	<span class="na">runCommand</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span>
	<span class="p">},</span>
	<span class="c1">// 返回品牌名称</span>
	<span class="nx">getBrand</span><span class="err">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">brand</span><span class="p">;</span>
	<span class="p">},</span>
	<span class="c1">// 返回内存大小</span>
	<span class="nx">getRam</span><span class="err">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">ram</span><span class="p">;</span>
	<span class="p">},</span>
	<span class="nx">msg</span><span class="err">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">Lenovo</span> <span class="o">=</span> <span class="nx">Computer</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
	<span class="na">init</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">ram</span><span class="p">,</span> <span class="nx">cpu</span><span class="p">,</span> <span class="nx">disk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="p">.</span><span class="err">\</span><span class="nx">_super</span><span class="p">(</span><span class="s1">'lenovo'</span><span class="p">,</span> <span class="nx">ram</span><span class="p">,</span> <span class="nx">cpu</span><span class="p">,</span> <span class="nx">disk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">lenovo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Lenovo</span><span class="p">(</span><span class="s1">'8'</span><span class="p">,</span> <span class="s1">'i7'</span><span class="p">,</span> <span class="s1">'500'</span><span class="p">);</span>
<span class="nx">lenovo</span><span class="p">.</span><span class="nx">msg</span><span class="p">(</span><span class="s1">'你的内存大小为：'</span> <span class="o">+</span> <span class="nx">lenovo</span><span class="p">.</span><span class="nx">getRam</span><span class="p">()</span> <span class="o">+</span> <span class="s1">'G'</span><span class="p">);</span></code></pre></figure>

<p>分析他的实现思路。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// Inspired by base2 and Prototype</span>
<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">initializing</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
        <span class="nx">fnTest</span> <span class="o">=</span> <span class="sr">/xyz/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">xyz</span><span class="p">;</span>
        <span class="p">})</span> <span class="p">?</span> <span class="sr">/</span><span class="se">\b</span><span class="sr">_super</span><span class="se">\b</span><span class="sr">/</span> <span class="p">:</span> <span class="sr">/.*/</span><span class="p">;</span>

    <span class="c1">// The base Class implementation (does nothing)</span>
    <span class="c1">// 基类提供全局Class方法</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">Class</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>

    <span class="c1">// Create a new Class that inherits from this class</span>
    <span class="c1">// 提供Class扩展方法，这里只能是单继承</span>
    <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 保存父级类的原型</span>
        <span class="kd">var</span> <span class="nx">_super</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>

        <span class="c1">// Instantiate a base class (but only create the instance,</span>
        <span class="c1">// don't run the init constructor)</span>
        <span class="nx">initializing</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="c1">// 创建父类对象用于继承，这里并不会调用init构造函数</span>
        <span class="kd">var</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="k">this</span><span class="p">();</span>
        <span class="c1">// 创建完毕父类对象后可以调用init构造函数</span>
        <span class="nx">initializing</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

        <span class="c1">// Copy the properties over onto the new prototype</span>
        <span class="c1">// 拷贝所有属性到创建好的父类对象中</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">name</span> <span class="k">in</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Check if we're overwriting an existing function</span>
            <span class="c1">// 这里就是拷贝传递进来的对象的。</span>
            <span class="c1">// 如果是属性直接拷贝</span>
            <span class="c1">// 如果是函数分2种处理。如果是普通函数也是直接拷贝</span>
            <span class="c1">// 如果是函数中调用_super方法，则需要进行代理</span>
            <span class="nx">prototype</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">prop</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"function"</span> <span class="o">&amp;&amp;</span>
                <span class="k">typeof</span> <span class="nx">_super</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"function"</span> <span class="o">&amp;&amp;</span> <span class="nx">fnTest</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">prop</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="p">?</span>
                <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 如果函数中有_super方法返回的是代理函数</span>
                    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                        <span class="c1">// 保存当前对象的_super函数</span>
                        <span class="kd">var</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_super</span><span class="p">;</span>

                        <span class="c1">// Add a new ._super() method that is the same method</span>
                        <span class="c1">// but on the super-class</span>
                        <span class="c1">// 这里把父类的_super方法拷贝到当前对象中</span>
                        <span class="k">this</span><span class="p">.</span><span class="nx">_super</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>

                        <span class="c1">// The method only need to be bound temporarily, so we</span>
                        <span class="c1">// remove it when we're done executing</span>
                        <span class="c1">// 调用父类的方法</span>
                        <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
                        <span class="c1">// 调用完毕后，归还子类的方法</span>
                        <span class="k">this</span><span class="p">.</span><span class="nx">_super</span> <span class="o">=</span> <span class="nx">tmp</span><span class="p">;</span>

                        <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
                    <span class="p">};</span>
                <span class="p">})(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">prop</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="p">:</span>
                <span class="nx">prop</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// The dummy class constructor</span>
        <span class="c1">// 子类的模板对象。每个子类都是基于它创建出来的，就是父类的prototype会附加到这个类上，也就是一个代理类</span>
        <span class="kd">function</span> <span class="nx">Class</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// All construction is actually done in the init method</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">initializing</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">init</span><span class="p">)</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">init</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Populate our constructed prototype object</span>
        <span class="c1">// 继承父类</span>
        <span class="nx">Class</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">prototype</span><span class="p">;</span>

        <span class="c1">// Enforce the constructor to be what we expect</span>
        <span class="c1">// 修正构造函数</span>
        <span class="nx">Class</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">;</span>

        <span class="c1">// And make this class extendable</span>
        <span class="c1">// 让子类也拥有exend方法</span>
        <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">;</span>

        <span class="k">return</span> <span class="nx">Class</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">})();</span></code></pre></figure>

<p>他这个Class.extend只能实现一对一继承，比如</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Computer</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span><span class="cm">/*xxxxx*/</span><span class="p">});</span>
<span class="kd">var</span> <span class="nx">Lenovo</span> <span class="o">=</span> <span class="nx">Computer</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span><span class="cm">/*xxxx*/</span><span class="p">});</span>
<span class="c1">// 无法实现多属性继承比如</span>
<span class="kd">var</span> <span class="nx">Computer</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">Class1</span><span class="p">,</span> <span class="p">{</span><span class="cm">/*自定义属性*/</span><span class="p">},</span> <span class="nx">Base1</span> <span class="cm">/*基类*/</span><span class="p">);</span></code></pre></figure>

<p>看完John Resig大神的继承方法之后，再来看下linkedin的继承模型<a href="https://github.com/linkedin/Fiber/blob/master/src/fiber.js">Fiber</a></p>

<p>看下他这个继承模型都提供了那些功能。</p>

<p>1、extend方法。公有和私有方法。</p>

<p>2、访问父类原型链，在你传递的构造函数中，Fiber会传给你base参数通过base参数可以调用父类原型上的方法。</p>

<p>3、Mixin一种接口的扩展方法。</p>

<p>4、decorate</p>

<p>5、proxy</p>

<p>分析代码如下</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/*global exports, global, define, module */</span>
	<span class="c1">// 兼容模块化方法</span>
    <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">factory</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">exports</span> <span class="o">===</span> <span class="s1">'object'</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Node. Does not work with strict CommonJS, but</span>
            <span class="c1">// only CommonJS-like environments that support module.exports,</span>
            <span class="c1">// like Node.</span>
            <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">factory</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">define</span> <span class="o">===</span> <span class="s1">'function'</span> <span class="o">&amp;&amp;</span> <span class="nx">define</span><span class="p">.</span><span class="nx">amd</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// AMD. Register as an anonymous module.</span>
            <span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">factory</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Browser globals (root is window)</span>
            <span class="nx">root</span><span class="p">.</span><span class="nx">Fiber</span> <span class="o">=</span> <span class="nx">factory</span><span class="p">(</span><span class="nx">root</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}(</span><span class="k">this</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">global</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// Baseline setup</span>
        <span class="c1">// --------------</span>

        <span class="c1">// Stores whether the object is being initialized. i.e., whether</span>
        <span class="c1">// to run the `init` function, or not.</span>
        <span class="kd">var</span> <span class="nx">initializing</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>

            <span class="c1">// Keep a few prototype references around - for speed access,</span>
            <span class="c1">// and saving bytes in the minified version.</span>
            <span class="nx">ArrayProto</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span>

            <span class="c1">// Save the previous value of `Fiber`.</span>
            <span class="c1">// 保存以前的Fiber值</span>
            <span class="nx">previousFiber</span> <span class="o">=</span> <span class="nx">global</span><span class="p">.</span><span class="nx">Fiber</span><span class="p">;</span>

        <span class="c1">// Helper function to copy properties from one object to the other.</span>
        <span class="c1">// 复制函数，浅拷贝</span>
        <span class="kd">function</span> <span class="nx">copy</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">name</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="nx">name</span> <span class="k">in</span> <span class="nx">from</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">from</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span> <span class="p">{</span>
                    <span class="nx">to</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">from</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// The base `Fiber` implementation.</span>
        <span class="c1">// 基类</span>
        <span class="kd">function</span> <span class="nx">Fiber</span><span class="p">()</span> <span class="p">{}</span>

        <span class="c1">// ###Extend</span>
        <span class="c1">//</span>
        <span class="c1">// Returns a subclass.</span>
        <span class="c1">// extend继承方法</span>
        <span class="nx">Fiber</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Keep a reference to the current prototye.</span>
            <span class="c1">// 当前对象原型的引用</span>
            <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span>

                <span class="c1">// Invoke the function which will return an object literal used to</span>
                <span class="c1">// define the prototype. Additionally, pass in the parent prototype,</span>
                <span class="c1">// which will allow instances to use it.</span>
                <span class="c1">// 调用传递进来的构造函数，并且给构造函数传入当前的原型，得到一个对象，该对象中所涉及的函数都持有对parent的调用权限</span>
                <span class="nx">properties</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">parent</span><span class="p">),</span>

                <span class="c1">// Stores the constructor's prototype.</span>
                <span class="c1">// 保存构造函数原型</span>
                <span class="nx">proto</span><span class="p">;</span>

            <span class="c1">// The constructor function for a subclass.</span>
            <span class="c1">// 子类构造函数</span>
            <span class="kd">function</span> <span class="nx">child</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">initializing</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// Custom initialization is done in the `init` method.</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">init</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
                    <span class="c1">// Prevent subsequent calls to `init`. Note: although a `delete</span>
                    <span class="c1">// this.init` would remove the `init` function from the instance, it</span>
                    <span class="c1">// would still exist in its super class' prototype.  Therefore,</span>
                    <span class="c1">// explicitly set `init` to `void 0` to obtain the `undefined`</span>
                    <span class="c1">// primitive value (in case the global's `undefined` property has</span>
                    <span class="c1">// been re-assigned).</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">init</span> <span class="o">=</span> <span class="k">void</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// Instantiate a base class (but only create the instance, without</span>
            <span class="c1">// running `init`). And, make every `constructor` instance an instance</span>
            <span class="c1">// of `this` and of `constructor`.</span>
            <span class="c1">// 这里跟john大神的原理一样，不调用init只是创建父类的对象实例</span>
            <span class="nx">initializing</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="c1">// 实例化父类对象实例(当前类)，然后子类继承它</span>
            <span class="nx">proto</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="k">this</span><span class="p">;</span>

            <span class="nx">initializing</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

            <span class="c1">// Add default `init` function, which a class may override; it should</span>
            <span class="c1">// call the super class' `init` function (if it exists);</span>
            <span class="c1">// 如果继承对象没有提供默认的init时则创建默认的init函数调用父类的init方法</span>
            <span class="nx">proto</span><span class="p">.</span><span class="nx">init</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">init</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">parent</span><span class="p">.</span><span class="nx">init</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">};</span>

            <span class="c1">// Copy the properties over onto the new prototype.</span>
            <span class="c1">// 用户自定义方法拷贝到proto原型中</span>
            <span class="nx">copy</span><span class="p">(</span><span class="nx">properties</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>

            <span class="c1">// Enforce the constructor to be what we expect.</span>
            <span class="c1">// 修正原型的构造函数为child，跟john那个extend里面的Class一样哈，只不过这里将属性和构造函数分开来了</span>
            <span class="nx">proto</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">child</span><span class="p">;</span>

            <span class="c1">// Keep a reference to the parent prototype.</span>
            <span class="c1">// (Note: currently used by decorators and mixins, so that the parent</span>
            <span class="c1">// can be inferred).</span>
            <span class="c1">// 保存父类原型的引用</span>
            <span class="nx">child</span><span class="p">.</span><span class="nx">__base__</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>

            <span class="c1">// Make this class extendable, this can be overridden by providing a</span>
            <span class="c1">// custom extend method on the proto.</span>
            <span class="c1">// 子类可以重写extend方法。如果不重写就是用Fiber的extend</span>
            <span class="nx">child</span><span class="p">.</span><span class="nx">extend</span> <span class="o">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">extend</span> <span class="o">||</span> <span class="nx">Fiber</span><span class="p">.</span><span class="nx">extend</span><span class="p">;</span>

            <span class="c1">// 返回子类对象，现在你可以是用他了 :)</span>
            <span class="k">return</span> <span class="nx">child</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="c1">// Utilities</span>
        <span class="c1">// ---------</span>

        <span class="c1">// ###Proxy</span>
        <span class="c1">//</span>
        <span class="c1">// Returns a proxy object for accessing base methods with a given context.</span>
        <span class="c1">//</span>
        <span class="c1">// - `base`: the instance' parent class prototype.</span>
        <span class="c1">// - `instance`: a Fiber class instance.</span>
        <span class="c1">//</span>
        <span class="c1">// Overloads:</span>
        <span class="c1">//</span>
        <span class="c1">// - `Fiber.proxy( instance )`</span>
        <span class="c1">// - `Fiber.proxy( base, instance )`</span>
        <span class="c1">//</span>
        <span class="c1">// 返回基于base上下文的代理对象，就是说instace的执行环境是基于base的this的</span>
        <span class="nx">Fiber</span><span class="p">.</span><span class="nx">proxy</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">instance</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">name</span><span class="p">,</span>
                <span class="nx">iface</span> <span class="o">=</span> <span class="p">{},</span>
                <span class="nx">wrap</span><span class="p">;</span>

            <span class="c1">// If there's only 1 argument specified, then it is the instance,</span>
            <span class="c1">// thus infer `base` from its constructor.</span>
            <span class="c1">// 如果传入一个参数，那么base执行环境就从他的构造函数中拿到__base__(因为上面保存了父类的原型)，这里就是修正base</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">instance</span> <span class="o">=</span> <span class="nx">base</span><span class="p">;</span>
                <span class="nx">base</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">__base__</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Returns a function which calls another function with `instance` as</span>
            <span class="c1">// the context.</span>
            <span class="c1">// 包装用户传递引来的函数，保证他的执行环境在__base__中</span>
            <span class="nx">wrap</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                    <span class="c1">// 保证执行环境</span>
                    <span class="k">return</span> <span class="nx">base</span><span class="p">[</span><span class="nx">fn</span><span class="p">].</span><span class="nx">apply</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
                <span class="p">};</span>
            <span class="p">};</span>

            <span class="c1">// For each function in `base`, create a wrapped version.</span>
            <span class="c1">// 如果父类对象有这个方法，就进行包装，包装后的函数放在iface中</span>
            <span class="k">for</span> <span class="p">(</span><span class="nx">name</span> <span class="k">in</span> <span class="nx">base</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">base</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">base</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">===</span> <span class="s1">'function'</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">iface</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">wrap</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// 返回包装后的对象</span>
            <span class="k">return</span> <span class="nx">iface</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="c1">// ###Decorate</span>
        <span class="c1">//</span>
        <span class="c1">// Decorate an instance with given decorator(s).</span>
        <span class="c1">//</span>
        <span class="c1">// - `instance`: a Fiber class instance.</span>
        <span class="c1">// - `decorator[s]`: the argument list of decorator functions.</span>
        <span class="c1">//</span>
        <span class="c1">// Note: when a decorator is executed, the argument passed in is the super</span>
        <span class="c1">// class' prototype, and the context (i.e. the `this` binding) is the</span>
        <span class="c1">// instance.</span>
        <span class="c1">//</span>
        <span class="c1">//  *Example usage:*</span>
        <span class="c1">//</span>
        <span class="c1">//     function Decorator( base ) {</span>
        <span class="c1">//       // this === obj</span>
        <span class="c1">//       return {</span>
        <span class="c1">//         greet: function() {</span>
        <span class="c1">//           console.log('hi!');</span>
        <span class="c1">//         }</span>
        <span class="c1">//       };</span>
        <span class="c1">//     }</span>
        <span class="c1">//</span>
        <span class="c1">//     var obj = new Bar(); // Some instance of a Fiber class</span>
        <span class="c1">//     Fiber.decorate(obj, Decorator);</span>
        <span class="c1">//     obj.greet(); // hi!</span>
        <span class="c1">//</span>
        <span class="nx">Fiber</span><span class="p">.</span><span class="nx">decorate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">instance</span> <span class="cm">/*, decorator[s] */</span> <span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span>
                <span class="c1">// Get the base prototype.</span>
                <span class="c1">// 获取到父类的原型对象</span>
                <span class="nx">base</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">__base__</span><span class="p">,</span>
                <span class="c1">// Get all the decorators in the arguments.</span>
                <span class="c1">// 取得包装函数</span>
                <span class="nx">decorators</span> <span class="o">=</span> <span class="nx">ArrayProto</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="nx">len</span> <span class="o">=</span> <span class="nx">decorators</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 先调用传递进来的包装函数，会给包装函数传递base(父类原型)，这里包装里面的对象持有对base的访问权限</span>
                <span class="c1">// 接着将包装好的对象拷贝给传入的obj(instance)就是第一个参数中</span>
                <span class="nx">copy</span><span class="p">(</span><span class="nx">decorators</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">call</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">base</span><span class="p">),</span> <span class="nx">instance</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c1">// ###Mixin</span>
        <span class="c1">//</span>
        <span class="c1">// Add functionality to a Fiber definition</span>
        <span class="c1">//</span>
        <span class="c1">// - `definition`: a Fiber class definition.</span>
        <span class="c1">// - `mixin[s]`: the argument list of mixins.</span>
        <span class="c1">//</span>
        <span class="c1">// Note: when a mixing is executed, the argument passed in is the super</span>
        <span class="c1">// class' prototype (i.e., the base)</span>
        <span class="c1">//</span>
        <span class="c1">// Overloads:</span>
        <span class="c1">//</span>
        <span class="c1">// - `Fiber.mixin( definition, mix_1 )`</span>
        <span class="c1">// - `Fiber.mixin( definition, mix_1, ..., mix_n )`</span>
        <span class="c1">//</span>
        <span class="c1">// *Example usage:*</span>
        <span class="c1">//</span>
        <span class="c1">//     var Definition = Fiber.extend(function(base) {</span>
        <span class="c1">//       return {</span>
        <span class="c1">//         method1: function(){}</span>
        <span class="c1">//       }</span>
        <span class="c1">//     });</span>
        <span class="c1">//</span>
        <span class="c1">//     function Mixin(base) {</span>
        <span class="c1">//       return {</span>
        <span class="c1">//         method2: function(){}</span>
        <span class="c1">//       }</span>
        <span class="c1">//     }</span>
        <span class="c1">//</span>
        <span class="c1">//     Fiber.mixin(Definition, Mixin);</span>
        <span class="c1">//     var obj = new Definition();</span>
        <span class="c1">//     obj.method2();</span>
        <span class="c1">//</span>
        <span class="c1">// 跟decorate一样一样的。也是持有base的访问权限，然后拷贝到传入的第一个参数中</span>
        <span class="nx">Fiber</span><span class="p">.</span><span class="nx">mixin</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">definition</span> <span class="cm">/*, mixin[s] */</span> <span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span>
                <span class="c1">// Get the base prototype.</span>
                <span class="nx">base</span> <span class="o">=</span> <span class="nx">definition</span><span class="p">.</span><span class="nx">__base__</span><span class="p">,</span>
                <span class="c1">// Get all the mixins in the arguments.</span>
                <span class="nx">mixins</span> <span class="o">=</span> <span class="nx">ArrayProto</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="nx">len</span> <span class="o">=</span> <span class="nx">mixins</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">copy</span><span class="p">(</span><span class="nx">mixins</span><span class="p">[</span><span class="nx">i</span><span class="p">](</span><span class="nx">base</span><span class="p">),</span> <span class="nx">definition</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c1">// ###noConflict</span>
        <span class="c1">//</span>
        <span class="c1">// Run Fiber.js in *noConflict* mode, returning the `fiber` variable to</span>
        <span class="c1">// its previous owner. Returns a reference to the Fiber object.</span>
        <span class="c1">// 还原以前定义的Fiber值</span>
        <span class="nx">Fiber</span><span class="p">.</span><span class="nx">noConflict</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">global</span><span class="p">.</span><span class="nx">Fiber</span> <span class="o">=</span> <span class="nx">previousFiber</span><span class="p">;</span>
            <span class="k">return</span> <span class="nx">Fiber</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="k">return</span> <span class="nx">Fiber</span><span class="p">;</span>
    <span class="p">}));</span>
<span class="p">}());</span></code></pre></figure>

<p>Fiber他这个继承模型还是比较不错的，继承都包装在了函数中，可扩展的东西就多了，比如私有方法。但是他也是单继承，不过他有mixin接口可以很好的让类实现某些接口但不需要继承。</p>

<p><b class="green">jquery、kissy、dojo等库/框架由于时间关系，留着后面点分析吧。</b></p>

<h3 id="section-2">4.面向对象的组件设计</h3>

<p>这就面向对象简单吧，可能你心里会骂：土豆你在逗我吗？这种代码我早就知道了，但是并没有卵用啊。我猜到了，所以举个例子，让面向对象有卵用起来。</p>

<p>先思考一下我们要写一个组件，组件要写成什么呀？路有千万种，怎么走完全看你自己喜欢，但是总好好坏之分，但是并无对错。</p>

<p>先说说我对组件的理解：</p>

<ul>
  <li>
    <p>核心层</p>
  </li>
  <li>
    <p>UI层</p>
  </li>
  <li>
    <p>组件层</p>
  </li>
  <li>
    <p>逻辑层</p>
  </li>
</ul>

<p>核心层：看名知意了，就是整个框架的底层，它提供了最底层的支撑，比如说 jQuery、underscore、zepto这种库。UI层：它是整组件的底层，它定义结构和样式。组件层：各种组件的封装，依赖，嵌套等等。但不涉及任何逻辑的东西。因为组件就需要有足够的复用性。逻辑层：根据使用场景不同，可能组件会跟着业务逻辑做出对应的修改，这时组件一般就不具备复用性</p>

<p>请看下面代码，一个组件库面向对象的基本思路，这里我写伪代码了哈。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 对象继承基</span>
<span class="kd">var</span> <span class="nx">Class</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>
<span class="c1">// 抽象组件通用的方法形成基类。jquery ui 是典型的代表</span>
<span class="kd">var</span> <span class="nx">UiBase</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
	<span class="na">el</span><span class="p">:</span> <span class="s1">'#box'</span><span class="p">,</span>					<span class="c1">// 组件元素</span>
	<span class="na">tamplate</span><span class="p">:</span> <span class="s1">'&lt;div&gt;&lt;/div&gt;'</span><span class="p">,</span>	<span class="c1">// 组件模板</span>
	<span class="na">init</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){},</span>			<span class="c1">// 提供组件初始化方法</span>
	<span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){},</span>		<span class="c1">// 提供组件渲染方法</span>
	<span class="na">destory</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){},</span>		<span class="c1">// 组件销毁方法</span>
<span class="p">});</span>
<span class="c1">// 然后我们需要一个搜索框的组件，可以这样</span>
<span class="kd">var</span> <span class="nx">Search</span> <span class="o">=</span> <span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">UiBase</span><span class="p">,</span> <span class="p">{</span>
	<span class="na">el</span><span class="p">:</span> <span class="s1">''</span><span class="p">,</span>
	<span class="na">teamplate</span><span class="p">:</span> <span class="s1">'&lt;input&gt;'</span><span class="p">,</span>
	<span class="na">init</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){},</span>
	<span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){},</span>
	<span class="nx">getDate</span><span class="p">():</span> <span class="kd">function</span><span class="p">(){},</span>	<span class="c1">// ajax获取数据</span>
	<span class="na">filter</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){}</span>		<span class="c1">// 根据业务过滤数据</span>
<span class="p">});</span>
<span class="c1">// 调用可以这样</span>
<span class="k">new</span> <span class="nx">Search</span><span class="p">({</span>
	<span class="na">el</span><span class="p">:</span> <span class="s1">'#search'</span>
<span class="p">});</span>
<span class="c1">// 这样就够了吗？不是的组件一个很重要的就是模块通信，所以这里我们要创建一个事件类，让组件基类继承事件对象，这模块和模块就能解耦了。</span>
<span class="c1">// 伪代码大概是这样</span>
<span class="kd">var</span> <span class="nx">Event</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">add</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){},</span>
	<span class="na">on</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){},</span>
	<span class="na">once</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){},</span>
	<span class="na">fire</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){},</span>
	<span class="na">remove</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){}</span>
<span class="p">}</span>
<span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">UiBase</span><span class="p">,</span> <span class="nx">Event</span><span class="p">);</span>
<span class="c1">// 你也可以在扩展出model、view等</span>

<span class="k">new</span> <span class="nx">Search</span><span class="p">({</span><span class="na">el</span><span class="p">:</span><span class="s1">'#search'</span><span class="p">}).</span><span class="nx">fire</span><span class="p">(</span><span class="s1">'reset'</span><span class="p">,</span> <span class="p">{</span><span class="na">opts</span><span class="p">:</span><span class="nx">opts</span><span class="p">});</span>	<span class="c1">// 通知search组件事件发生，并传递参数</span></code></pre></figure>

<p>这里我偷懒的全些的伪代码，只是提供一种思想的思想。</p>

<p>总结：学习了javascript对象的基本形态，javascript对象如何继承，javascript对象继承的各种实现方法，组件化的一种思路。最后写代码重要的时思想，不要别说怎么怎么样，你自己思考过吗？为何要这样？你问过自己吗？盲目跟风，只会让你的思想变成癌症，思想变得僵化。</p>

</article>









      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      &copy; 2015 <a href="http://createthink.net">createthink.net</a> with Help from <a href="http://jekyllrb.com/">Jekyll</a> and Theme crafted with by <a href="http://johnotander.com">John Otander</a>
    </small>
  </div>
</footer>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?86487f6d309f8a041841232abb6ff18d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</body>
</html>
