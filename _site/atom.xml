<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>蒋著[tudousi] - 博客</title>
 <link href="http://tom.preston-werner.com/atom.xml" rel="self"/>
 <link href="http://tom.preston-werner.com/"/>
 <updated>2015-01-29T18:07:53+08:00</updated>
 <id>http://tom.preston-werner.com/</id>
 <author>
   <name>tudousi</name>
   <email>41871879@qq.com</email>
 </author>

 
 <entry>
   <title>IE display:inline-block 问题</title>
   <link href="http://tom.preston-werner.com/2015/01/29/inline-block.html"/>
   <updated>2015-01-29T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2015/01/29/inline-block</id>
   <content type="html">&lt;p&gt;display:inline-block 布局时使用挺多的，但是在 IE8 以下，并不好用。可以设置宽度但，是有个问题就是无法成为内联块（不能并排）。&lt;/p&gt;

&lt;p&gt;IE8 以下看下面的例子，分析下原因：&lt;/p&gt;

&lt;iframe style=&quot;width: 100%; height: 100px&quot; src=&quot;http://sandbox.runjs.cn/show/v8widfoi&quot; allowfullscreen=&quot;allowfullscreen&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;


&lt;p&gt;问题就是在 IE8 以下，区块元素设置了 display:inline-block 仅仅是触发了 hasLayou，而元素本身还是区块元素。所以他们还是占一整行。（&lt;a href=&quot;http://www.blueidea.com/tech/site/2006/3698.asp&quot;&gt;hasLayout&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;我们已经知道问题，那么如何让 IE8 以下的浏览器也能实现 inline-block 捏。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;display:inline-block;
*+display:inline;
zoom:1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*+display:inline; 让 IE8 以下的浏览器先转为内联元素，然后使用 zoom:1; 触发 hasLayou。这个兼容性还可以。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>jqueryui 皮肤</title>
   <link href="http://tom.preston-werner.com/2015/01/19/jquery-ui.html"/>
   <updated>2015-01-19T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2015/01/19/jquery-ui</id>
   <content type="html">&lt;h3&gt;jqueryui 的一个皮肤&lt;/h3&gt;

&lt;p&gt;jqueryui皮肤下载&lt;a href=&quot;/resource/2015-01-19/jquery-ui-1.11.2.custom.zip&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;// 903行出增加了一个 css 
-webkit-box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
-moz-box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
background-color: #e8e8e8;
background-image: -moz-linear-gradient(top, #e8e8e8, #e9e9e9);
background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#e8e8e8), to(#e9e9e9));
background-image: -webkit-linear-gradient(top, #e8e8e8, #e9e9e9);
background-image: -o-linear-gradient(top, #e8e8e8, #e9e9e9);
background-image: linear-gradient(to bottom, #e8e8e8, #e9e9e9);
background-repeat: repeat-x;
filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#e8e8e8', endColorstr='#e9e9e9', GradientType=0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/resource/images/jqueryui.png&quot; alt=&quot;jqueryui 皮肤&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;`javascript&quot;&gt;// 皮肤编辑器地址
http://jqueryui.com/themeroller/#!zThemeParams=5d00000100e905000000000000003d8888d844329a8dfe02723de3e5701fa198449035fc0613ff729a37dd818cf92b1f6938fefa90282d04ae436bb72367f5909357c629e832248af2c086db4ab730aa4cced933a88449eca6115377f3b23d47f58a712d809b6088edfb34ad8fa47af622bb589c17f3586b572ce15054212a8ef4577d92e87827aec849a7dbd04711c95fc4678fab7c5e904e69767c432f1411f7a5448c6da4d5d3868bd628000e1b1da0fe07cf120c558a5d471a5b0f7660858769bb95610c1b20d69950045dabe9b4ff7849b167884ed09e15383485388ee84db8017b7b0624ccee56916a5d8981cd311cad3fb2ec1b63c6620fc82bdc4718e620a64665d23cf04f2c08d6438156a008831a5be80fdec5d6e8fc8eab81455b6a1fcc278170dfc2d045ca0c0fc43ba05b34519550084254be28afc63291978e75ae5b06aac243f8efa920a50a8ef7a02184ee79e9c183784c50b039bba9b81f291318a2c4f259fdd32d76f7b7b6ade155d036ad1f01d7d13e4e78c380fcf06e937a0848f0fe85ca9ae72646ab82fc5304f42867c185c06f4177739923ce9130cde92f00720bc44d95160f52cf53d2d98dc49916489e56c8f03e7c0f3c64a071a5c85898f6250229d99354d96d21ffd8cef3ce
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>如何写好CSS？（OOCSS\DRY\SMACSS）[转]</title>
   <link href="http://tom.preston-werner.com/2015/01/19/css-principle.html"/>
   <updated>2015-01-19T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2015/01/19/css-principle</id>
   <content type="html">&lt;p&gt;很久没有写博客了，一是刚入职比较忙，二是因为总有学到新的有趣的东西，停不下脚步来总结一下。最近出差到了帝都，反而能挤出些时间来写点什么了，也正好趁着出差做的这个项目讨论一下CSS理论。&lt;/p&gt;

&lt;p&gt;我现在面对的CSS基本上就是一个三头六臂的怪物，一点不夸张，因为真的是三头六臂，同一个样式在同一个element上作用了好几遍，而同一个样式又分散在4，5个class上，优先级有很多层。可以看得出这个怪物不是一个人造就的，早期的开发者选择了SCSS技术，但混乱的import导致了一些基本的样式被多次调用，而后面的开发者又为了摆脱之前的混乱引入了其他共用样式，但无济于事。原因出在HTML上，CSS依托于HTML没有被正确的抽象，而HTML又完全的依赖业务，所有class以业务取名，HTML和CSS基本没有复用，最终抽出的共用样式也仅仅是又一次的重复。CSS重构最难的地方在于没有脚手架，即测试。虽然有一些方法来测试，比如reftest，但还不够成熟。抱着有总比没好的心态，CSS被一层又一层的覆盖了上去。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h2&gt;真正的问题是什么？&lt;/h2&gt;

&lt;p&gt;CSS即层叠样式表，所以一层一层覆盖其实是其本质特征。真正的问题在于维护，许多人认为CSS仅是样式，不是代码，无需维护，所以任意书写，只要将自己需要的样式的优先级设为最高即可，才导致了深层级CSS的出现，因为每次添加一个样式就必须比以前的优先级高才能在页面看到。深层级不仅造成维护性降低，可读性也是一个问题，人不是机器，无法很优雅的按优先级阅读，所以很难确认一个样式用于哪里，其实还存在许多的冗余样式，在任何地方都被覆盖的样式。这样的代码在扩展性上，一开始反而是有优势的，因为添加一个新class，无需担心影响其他地方，但慢慢随着项目规模的增大，页面增多，需要复制样式的地方也越来越多，它们之间又存在微小的差异，设计的更改，需求的变化，这一切都会将这种快餐式的CSS推进柏油坑。因为难以维护，所以无法响应需求，所以无法复用，只能复制，恶性循环。&lt;/p&gt;

&lt;p&gt;正如上面所说的，问题在于可读性、维护性、扩展性、复用性这几个方面。所以只要提高它们就能解决问题, 虽然这么说，也不是如此简单的。先来谈谈在CSS中，这些概念都有着怎样的意义。&lt;/p&gt;

&lt;h4&gt;可读性&lt;/h4&gt;

&lt;p&gt;有人认为CSS不是程序，不需要可读性，有人认为CSS只要写出来就有可读性，因为很简单。抛开各种预处理器不说，原生CSS结构确实简单，没有需要编程的部分，但仍然可能导致混乱。原因有二，一是CSS可以层叠，其中涉及到了优先级和作用范围，如果写的不好，人很难读出其中的意义，二是CSS属性众多，加上CSS3引入了很多用法独特的属性，一个选择器可能包含几十个属性。比如下面这段我随便写的CSS代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;span {
    -webkit-box-shadow: 6px 4px 4px red;
    -moz-box-shadow: 6px 4px 4px red;
    box-shadow: 6px 4px 4px red;
}
div span {
    border-width: 4px;
    border-style: dotted;
    border-color: blue;
}
#box {
    border-left: 2px solid red;
    border-bottom: 2px solid red; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;乍一看也没什么，都是border，大致能看出来这段CSS只是为了添加一个红色的阴影让box看起来比较立体。但中间的部分似乎是捣乱的，你可能会说这太傻了，看不到吗。是的，当这3部分散落在上万行的CSS中时，肯定看不到。于是有人很自然的想起了我们可爱的浏览器，没错，在浏览器中可以快速找到作用于目标的CSS样式，但这也是万恶之源。首先我假设你不知道中间那部分东西是为了什么而写的，因为你是靠浏览器找到它的。然后剩下两种可能，不管三七二十一改了再说和看看它为什么存在。前者悲剧的可能性是100%，后者悲剧的可能性是90%，因为你已经掉坑里了，很快我们会发现要修改它还牵扯到了另外的地方，接着在浏览器中探索到另一个莫名其妙的样式，当你弄懂全部的时候，你应该已经把上万行的代码弄了个一清二楚了，也许最幸运的是，浪费了几个小时的时间发现只需要修改一行就能达到目的。&lt;/p&gt;

&lt;p&gt;当然，我们可以天真的认为，只要把他们写在一起就可以了，这样找起来很简单。而我将继续顺着这样的思路来尝试曝露问题。&lt;/p&gt;

&lt;h4&gt;维护性&lt;/h4&gt;

&lt;p&gt;所谓物以类聚是很有道理的，人们习惯将事物归类，但问题是分类标准，样式并不关心业务，无论是什么文字内容，还是功能有何不同，它在乎的只是样式，比如文字的尺寸，间距和宽高，颜色等等。如果简单的将一个组件的样式放在一起，势必带来的就是小段代码的重复书写。不觉得有多严重？我来举个栗子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aside {
    box-shadow: 6px 4px 4px #AA3343;
}
nav {
    box-shadow: 6px 4px 4px #AB3633;    
}
.item {
    box-shadow: 6px 4px 4px #AA3732;
}
.item.otherStatus {
    box-shadow: 6px 4px 4px #AA3132;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续说上面的例子，box需要阴影，但如果这个项目的UI统一风格，包括sidebar，navigator以及item都需要这样的阴影呢？再如果，明天客户或者UX一拍脑袋，这个阴影应该是灰色的不该是红色的呢？不要继续天真的认为全局替换是救命稻草。首先，没有几个网站会用red，blur做色调的，你用的应该是#AA3333，这样的代码，然后你发现sidebar用了#A43433，而navigator是#AB3633，等等，item有两个状态，而两个状态对应的颜色是不一样的。这怎么可能？但当你打开浏览器的时候你会发现本来就相差无几的颜色，在阴影中变得一模一样了，谁看的出来呢，当初使用的时候可能也不过是随意的在mockup中取的一个颜色。&lt;/p&gt;

&lt;p&gt;大量的重复带来的不仅仅是代码的冗余，我们必须靠人力去同步它们，而人很难保证它们的修改是完全一致的，尤其是当它们中引入了一些不一致的独特的东西时。不要小看CSS，其后果就是进度和人力的压力，后面就是PM有没有读过《人月神话》的事了。&lt;/p&gt;

&lt;p&gt;肯定有人在想，谁让你当初要写成这样呢。我们在读代码的时候最喜欢问，当初为什么要这么写？但慢慢的你会读出它的历史，有时候它是身不由己的。这就涉及到了下一个要讨论的内容。&lt;/p&gt;

&lt;h4&gt;扩展性&lt;/h4&gt;

&lt;p&gt;扩展性是一个具有欺骗性的东西，所谓的扩展性其实就是在现有基础上再次开发新东西的性能，但我认为它还必须有前提条件，那就是保持可读性与维护性。&lt;/p&gt;

&lt;p&gt;简单的追求可维护性是自取灭亡，原因很简单，将新旧代码完全分离的时候扩展性最高，因为不必担心对以前的部分有影响，新的样式可以随意发挥。是不是很神奇，这样想的我们写下的代码，肯定就是前面我们追问的代码。所以自己回答自己吧，当初没考虑可读性和维护性，只想着快点增加新的样式，就这么写了。&lt;/p&gt;

&lt;p&gt;那什么才是一个好的扩展性呢，简单来说，就是多功能产品。比如一个box，也许它的样式就时&lt;/p&gt;

&lt;h4&gt;复用性&lt;/h4&gt;

&lt;p&gt;似乎我一直在说的就是重复，那我们就来说说复用性，如何才能复用CSS代码是一个很大的问题，比如粒度，是一两个属性进行复用还是一大组选择器进行复用呢，再比如对象，是为了class复用属性，还是为了html复用class呢。这些选择不算太重要，但是带来的影响却很重大，可以说是整个CSS结构的改变。下面继续用box的阴影来讨论复用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.shadow {
    -webkit-box-shadow: 6px 4px 4px #A93334;
    -moz-box-shadow: 6px 4px 4px #A93334;
    box-shadow: 6px 4px 4px #A93334;
    border-left: 2px solid #A93334\9;
    border-bottom: 2px solid #A93334\9; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样看起来我有了一个shadow的class可以给任意的目标加上这个阴影了，但这导致了一个复用的问题，和上面那段捣乱的CSS样式一样，如果item已有另外2个border了，那这个class是无法去除的。所以复用时不仅要考虑需要什么，还要考虑不需要什么。另外一些必须的属性比如display还有overflow等也是要考虑的，因为user agent的原因，很多属性是隐藏在element中的。&lt;/p&gt;

&lt;h2&gt;如何解决问题？&lt;/h2&gt;

&lt;p&gt;主流的CSS原则有OOCSS，DRY，SMACSS以及BEM，他们皆是为解决CSS的各种问题而生。&lt;/p&gt;

&lt;h4&gt;OOCSS&lt;/h4&gt;

&lt;p&gt;OOCSS即面向对象的CSS，这里对象指的是页面中的元素对象，与传统编程中的面向对象不太相同，比如不存在方法这种东西，硬要说的话，附加的一些class可以看作是继承或者接口之类的东西来实现对象的差异化。比如电商网站中的商品就是一个典型的对象，它们既有许多相同的部分，又有许多差异，宽高、按钮、图片、标题等基本布局都是相同的，而边距、线框、背景颜色、字号等都是差异化的。由此按照OOCSS的指导原则，我们应该写一个product class，然后为其添加一些border、theme之类的class来差异化它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.product {
    display: block;
    overflow: hidden;
    float: left;
    width: 200px;
    height: auto;
}
.product-head{...}
.product-body{...}
.product-foot{...}

.product-theme-black {
    background: black;
    color: white;
}

.product-border {
    border: 1px solid #333;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在以上两种附加class的作用下，我们在html中就可以获得4种不同的product样式，随着附加class增加，product的样式也会呈指数增加，千变万化。这仅仅是一个简单的例子，意在点出OOCSS的理念，但并没有突出它的意义所在。别着急，先来看看OOCSS的两大原则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1. 分离容器与内容&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所谓的容器即包裹对象的元素，比如一个div，我们经常会命名为wrap、container、body等。那么如何才算是分离容器与内容呢？很简单，一句话，内容在哪都可用。也就是说不应该出现这样的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.container .product {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样干的结果就是复用性大大降低，因为只能在这个容器内使用它了。但这并不代表我们应该将所需的样式全部一股脑的扔进单独的class中，对于差异化应该单独放在一个class中，这才是OOCSS的精髓。&lt;/p&gt;

&lt;p&gt;举个例子，当我们既不想牺牲太多性能，又想来个瀑布流显摆显摆的时候，大部分前端都会使用column，类似泳道的设计。你想说哦不，这是伪pinterest，但是谁在乎呢，用户是不会有闲工夫拖拽浏览器的宽度来鉴别它的，在IE下商品多的时候至少不会太卡。哈，别较真，首先分为几个column，然后按照高度往里填放商品，先来看看下面的代码吧，我有省略一些样式避免误导：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.column {
    height: auto;
    width: 200px;
}

.product {
    width: 180px;
    margin-right: 20px;
    margin-bottom: 10px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来不错，每列200px宽，商品放入其中，水平间距要大，垂直间距要小些才像column。但是等等，我们总还是需要整齐摆放的商品列表的对不对。也许margin并不是product的必要属性，至少它应该是可变的。我们抽出它来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.product {
    width: 180px;
}

.vertical-product {
    height: 400px;
    margin-right: 10px;
    margin-bottom: 10px;
}

.horizontal-product {
    height: auto;
    margin-right: 20px;
    margin-bottom: 10px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样便将column或list之类的容器与product分开来毫无关系了，即使以后出现了其他组织形式，只要product的基本结构没有变都可以直接复用，无非是添加一些附属样式到新的xxx-product的class中。另外这样做还有一个好处，设计逻辑放在了HTML中，CSS更加强大。&lt;/p&gt;

&lt;p&gt;什么是样式逻辑？商品在瀑布流中不定高，在列表中定高，这就是一种样式的逻辑，如果用父子选择器的形式写在CSS中，那它就失去了自由。而放在HTML通过选择添加何种附属class来展现不同形式的product，则非常的自由与灵活。另外值得一说的是，margin-bottom是一样的，但我们应该各自放在各自的class里面，原因很简单，它们仅仅是一不小心恰好一样，在设计逻辑中它们并不是一样的bottom，这里并不是重复，而是看起来一样。如果以后需要改变其中的一个bottom，共用则显得非常别扭。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2. 分离皮肤与结构&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第二点很容易理解，皮肤（theme）就是视觉效果，即使被剔除网页也没有什么影响的就是皮肤；而结构指地并不是像HTML这样抽象的结构，因为CSS毕竟还是样式，所以结构只是相对的页面结构。&lt;/p&gt;

&lt;p&gt;先来看看我们的product吧，添加一些背景色和边框：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.product {
    width: 200px;
    background: #F6F2F2;
    border: 1px solid #C4A0A0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来还不错，不过设计师都是自大狂，精心的调色，完美的搭配，绝对不会让你仅仅使用这么一次的，页面的其他模块、sidebar甚至是header都可能采用相同的背景颜色与边框，它们甚至可能互相嵌套。好吧，这其实在设计上是为了视觉统一，毕竟没有几个设计大师能hold住3，4种以上的颜色。所以我们能做的并不是在每个class中添加这样的样式，而是把它提出来成为独立的class，原因就像我开篇说的那样，颜色为混沌之源。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.main-bg {
    background: #F6F2F2;
}

.main-border {
    border: 1px solid #C4A0A0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以在页面中随时使用主要的设计元素了，而且需要修改时也非常的简单，不用担心有什么地方漏掉。另外我将背景与边框分为了两个class，原因还是设计逻辑应该放在HTML，背景与边框并不是一定同时出现的，两者的关系应该由HTML决定，即使设计上逻辑决定了两者的绑定，在实现时也有可能因为HTML结构而放在两个不同的元素上。&lt;/p&gt;

&lt;p&gt;OOCSS强调class，将每组样式写成一个class方便HTML中使用，众多class组合起来能千变万化组成一个对象。所以如果是想一劳永逸的写一套UI作为开发时使用的样式，我建议使用OOCSS来进行开发。但它也有缺点，过多的将设计逻辑放在HTML中，极大的自由化了页面开发时的选择，如果写HTML的开发者不能很好的理解整套CSS的结构，较易在HTML中造成class混乱。&lt;/p&gt;

&lt;h4&gt;DRY CSS&lt;/h4&gt;

&lt;p&gt;DRY就是Donot repeat youself 不要重复。但其实这个名字有点无趣，哪个理论不是消除重复呢，但如何消除才是意义所在。总的来说我认为DRYCSS与OOCSS是两个极端，所以我将会以对比的方式来讲讲DRYCSS的内容。使用DRYCSS很简单，三步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1. 分组可复用属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DRYCSS跟OOCSS有点像，第一步都是分组样式，消除重复，但就像我说的，关键在于如何。OOCSS将样式集合看作对象，所以分组的逻辑是，某个元素本身应该是什么样的，而DRYCSS则关注重复，无论什么逻辑，只要是一样的就应该只有一个。其中粒度是值得思考的问题，如果太细，那只会成为一行样式一组这样无意义的情况，如果太粗，又会变成毫无复用性的庞然大物。我认为可以将一些有关联的缺了A时B就没作用的样式分为一组，还可以将某些惯用搭配分为一组。下面举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    float: left;
    position: absolute;
    display: inline-block;
    overflow: hidden;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一组样式，可用来触发&lt;a href=&quot;http://kayosite.com/block-formatting-contexts-in-detail.html&quot;&gt;Block formatting Contexts（块级格式化上下文）&lt;/a&gt;，如此就完成了一组样式。接着再写2组关于尺寸的样式吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    width: 960px;
    height: auto;
}
{
    width: 720px;
    height: 600px;
}
{
    width: 220px;
    height: 600px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是三组样式用来布局，将页面分为左右两部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2. 按逻辑为分组命名&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接着我们来为其命名，其实就是添加一个ID选择器，但是我们并不真的使用它，而是用来标示该组样式。下面就来命名上面所分组的样式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#BLOCK_FORMATTING_CONTEXTS
{
    float: left;
    position: absolute;
    display: inline-block;
    overflow: hidden;
}

#LAYOUT_FULL
{
    width: 960px;
    height: auto;
}

#LAYOUT_CONTENT
{
    width: 720px;
    height: 600px;
}

#LAYOUT_SIDEBAR
{
    width: 220px;
    height: 600px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一步类似OOCSS的class，它决定了每组样式所代表的逻辑或用途，然而DRYCSS多了最关键的下一步，也是与OOCSS本质区别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3. 为各个分组添加选择器&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DRYCSS在使用时和OOCSS有着巨大的差异，在CSS文件中写入HTML中的class选择器来使用这些分组后的样式，而不是直接在HTML中使用CSS文件中写好的class。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.header,
.container,
.content-right,
.content-left,
#BLOCK_FORMATTING_CONTEXTS
{
    float: left;
    position: absolute;
    display: inline-block;
    overflow: hidden;
}

.header,
.navigator,
.container,
#LAYOUT_FULL
{
    width: 960px;
    height: auto;
}


.content-right,
.section,
#LAYOUT_CONTENT
{
    width: 720px;
    height: 600px;
}

.content-right,
.sidebar,
.profile,
#LAYOUT_SIDEBAR
{
    width: 220px;
    height: 600px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，使用DRYCSS时，在HTML中所写的class将会非常表意，元素本身是什么用来做什么，就使用其意义的class命名，而且基本上是一个元素对应一个class，HTML将变的简单明了。另外DRYCSS也是相对于OOCSS的一种逆向思维，这才是最有趣的地方。在开发中，不应该像OOCSS那样思考如何应对未来假象的HTML，而是仅仅思考CSS本身。&lt;/p&gt;

&lt;p&gt;总的来说，OOCSS适合开发CSS框架或整套UI模版，是自外向内的UI开发方式；而DRYCSS则适合拯救混沌的HTML，或者加强HTML的结构性和表意性，是自内向外的UI开发方式。这里的内指地是HTML结构，外指地是CSS样式。&lt;/p&gt;

&lt;h4&gt;SMACSS&lt;/h4&gt;

&lt;p&gt;这是一个相对繁杂的CSS理论，分为Base、Layout、Module、Status和Theme共五个部分。不过它的核心思想仍然和OOCSS类似，鼓励使用class。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1. Base 基本属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基础属性很容易理解，就是最基本的东西，很多样式简单的网站都采用一个简单的二级CSS文件模式，一个base.css通用于所有页面，而每个页面有一个特定的CSS文件，我想这就是Base的雏形。要说具体是什么，比如reset文件，再比如放置clearfix或BFC的一些类似工具集的文件。&lt;/p&gt;

&lt;p&gt;其实最终会发现，在Base中的CSS属性将会是几乎全站都要用到的属性，但我不想这么描述Base，因为这会误导人。大多数情况下，在一个网站建立之初也只会有几个简单的页面，于是这几个页面都要用到的属性就变成了通用属性，但并不是这么简单的。随着网站规模的扩大，需求的增加，设计师们灵感的迸发，所谓的通用和统一也在发生着潜移默化。所以在编写Base时，应该遵循的基准是，哪些样式是你做下一个网站时也会想用的，哪些样式即使设计改变了也只需要改变一些数值和颜色，哪些样式是一些基本原则；而不应该将目前大部分页面都在使用的样式放在Base中，还是那个道理，它们也许仅仅是恰好相同，而非逻辑一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2. Layout 布局&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;布局是一个网站的基本，无论是左右还是居中，甚至其他什么布局，要实现页面的基本浏览功能，布局必不可少。SMACSS将这一功能单独提出也是非常正确的，另外还约定了一个前缀&lt;code&gt;l-/layout-&lt;/code&gt;来标识布局的class。举个最普遍的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.l-header {}
    .l-brand {}
    .l-navigator {}
.l-container {}
    .l-sidebar {}
    .l-content {}
.l-footer {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是一个简单的左右布局，导航和Logo中规中矩在最顶部。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3. Module 模块&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;模块是SMACSS最基本的思想，同时也是大部分CSS理论的基本，将样式模块化就能达到复用和可维护的目的，但是SMACSS提出了更具体的模块化方案。首先表象上来看，SMACSS中的模块应该拥有一个名字，并且为其class名，而模块其他class皆以为前缀。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.product {}
    .product-title {}
    .product-image {}
    .product-border {}
    .product-shadow {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到例子中product是一个模块，title和image是包含在模块内的组件，可用可不用；border和shadow是类似OOCSS的附加class用来改变模块本身。总之，在模块内可以使用其名称做前缀任意组织模块结构，但目前是让其变得更易用，提高可扩展性和灵活度，如果仅仅为了某些功能而特意写一些class就有点有形无实的感觉了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;4. State 状态&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;状态经常和JavaScript放在一起使用，它是一种用来标识页面状态的class，无论是为用户标识还是用程序标识。还是一个常见的例子，马上就明白。active经常用来表示当前的tab，或者当前选中的目标，这就是一种状态，无论是样式还是程序都需要知道它。&lt;/p&gt;

&lt;p&gt;SMACSS仍然有一个对应的前缀用于标示状态class，&lt;code&gt;is-&lt;/code&gt;是一个合适的词，指明某一元素是什么状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;5. Theme 主题&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主题就是皮肤，和OOCSS的分离皮肤与结构不谋而合。更重要的是对于可更换皮肤的站点来说，这样的分离是非常必要的，只需要更换加载的theme文件即可将皮肤更换。&lt;/p&gt;

&lt;p&gt;总的来说，SMACSS是一个较为注意细节与实现的CSS理论，非常适合初涉CSS的人，它可以让你的CSS跑在轨道上而不至于脱轨。其思想也与OOCSS有很多相通之处，如果没有适合的方案，我建议新手可以适当的融入OOCSS的思想而使用SMACSS的结构，这样写出来的网站样式至少不会马上陷入泥沼。&lt;/p&gt;

&lt;h2&gt;哪一个好用呢？&lt;/h2&gt;

&lt;p&gt;谈了许多的CSS原理，已经有点眼花缭乱，到底哪个好呢？这个问题又归结到了最佳实践上，虽然我并不认为有这样的实践，但我认为一个项目一定会有适合的实践，比如前面说的，如果你想做一个CSS框架然后再写HTML，那就用OOCSS；如果你想先写HTML或者已经有一个旧的页面，那DRYCSS应该很适合你；如果新手不知如何下手，那SMACSS可以指导你入门。&lt;/p&gt;

&lt;p&gt;无论如何，在我过去很长一段时间的独立UI开发“生涯”中，这些情况我都遇到过，也有一些自己的想法，我想我将在下一篇博客中谈谈自己对CSS的理解，并尝试整理出一些类似理论的东西来。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.tychio.net/tech/2014/03/16/css-principle.html&quot;&gt;原文连接&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>javascript 对象继承</title>
   <link href="http://tom.preston-werner.com/2014/12/31/object-extend.html"/>
   <updated>2014-12-31T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2014/12/31/object-extend</id>
   <content type="html">&lt;h3&gt;JavaScript 对象基础和概念&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;JavaScript 是基于原型的面向对象语言，并不像 JAVA、C++ 这种基于对象的语言。如果要理解 JavaScript 中的对象，理解原型 (prototype) 和构造函数 (constructor) 是非常重要的。&lt;/p&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;构造函数 (constructor)&lt;/li&gt;
&lt;li&gt;原型对象 (prototype)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;JavaScript 中的构造函数不同于其他基于对象的语言，它是一个函数，比如： function Class(){} 这就是构造函数，可以看下 js 中的构造函数和其他语言的构造函数的区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// javascript
function Person(){}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;// java
class Person {
    public Person(){}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;// c++
class Person {
    public:
        Person(){}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;// php
class Person {
    function __construct(){}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了扯得有点远，js 中的构造函数 (constructor) 是用来初始化对象的。&lt;/p&gt;

&lt;p&gt;所有的构造函 (constructor) 数都有一个 prototype 属性，它就是原型。js 就是靠他实现继承的。&lt;/p&gt;

&lt;p&gt;我们现在把构造函数拿来分析下:&lt;br&gt;
&lt;img src=&quot;/resource/javascript-extend/javascript-extend-1.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编号 1 就是每个构造函数的原型(prototype)&lt;/li&gt;
&lt;li&gt;编号 2 每个原型中都有一个属性 construct(构造函数)&lt;/li&gt;
&lt;li&gt;编号 3 只要是对象实例就会有一个 __proto__ 属性它指向构造函数所继承的原型的引用(prototype)。&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;原型链 (prototype chain)&lt;/h4&gt;

&lt;p&gt;__proto__ 是原型链实现的关键，每个对象实例都包含一个 __proto__ 属性，它指向构造函数 (constructor) 属性的引用。&lt;br&gt;
&lt;img src=&quot;/resource/javascript-extend/javascript-extend-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面的代码证明了 p 的对象实例属性 __proto__ 是指向构造函数 Person 的原型 (prototype)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function Person(){}
var p = new Person();
console.log(p.__proto__ === Person.prototype);  // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;函数 (function) 对象的原型链&lt;/h4&gt;

&lt;p&gt;在JavaScript中，函数（function）是一个特殊的对象，所有函数都是构造函数Function的实例，所以，函数的原型链与new操作符实例化对象的原型链会不同，先看下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function Person() {}
alert(Person.__proto__ === Object.prototype); // false
alert(Person.__proto__ === Function.prototype); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 js 中函数 (function) 是一个特殊的对象，所有的函数 (function) 都是构造函数 (Function) 的实例。&lt;/p&gt;

&lt;p&gt;对于上面的 Person 函数现在来看下它的原型链是怎么样的&lt;/p&gt;

&lt;p&gt;Person -&gt; __proto__ -&gt; Function.prototype -&gt; __proto__ -&gt; Object.prototype -&gt; __proto__ -&gt; null&lt;/p&gt;

&lt;p&gt;javascript 对象结构图&lt;br&gt;
&lt;img src=&quot;/resource/javascript-extend/javascript-extend-3.png&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;javascript 对象实例&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;一个基本类
这里的 this 指向的是 new 出来的对象实例，所以构造函数会给对象实例添加一系列初始化的属性&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// 版本1 构造函数初始化属性
function Person(name, age){
    this.name = name;
    this.age = age;
    this.talk = function(){
        console.log('hello my name is:' + this.name);
    };
}
var td = new Person('tudou', 22);
td.talk();
// 版本2 在原型是添加属性和方法
function Person(name, age){
    this.name = name;
    this.age = age;
}
Person.prototype.talk = function(){
    console.log('hello my name is:' + this.name);
};
var td = new Person('tudou', 22);
td.talk();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本类讲完了，来看下在 js 中如何实现继承的，看下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function Person(name, age){
    this.name = name;
    this.age = age;
    console.log('Person constructor');
}
Person.prototype.talk = function(){
    console.log('hello my name is:' + this.name);
};
function Programmer(){
    // 调用父类构造函数来初始化 Programmer 的属性
    Person.apply(this, arguments);
    console.log('Programmer constructor');
}
// 简单粗暴的把 Programmer 对象的原型属性指向 Person 的原型
Programmer.prototype = Person.prototype;
Programmer.prototype.talk = function(){
    console.log('i age is:' + this.age);
};
var p = new Person('tudou', 22);
var td = new Programmer('tudou', 22);
p.talk();   // i age is:22
td.talk();  // i age is:22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码是一种暴力继承，这样做不是最佳方法，作为一个君子，此方法不可用。有一个坏处：Programmer.talk 会覆盖 Person.talk。&lt;/p&gt;

&lt;p&gt;针对上面的优化继承方案&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// 原型继承修改为
Programmer.prototype = new Person();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做的好处就是 Programmer.prototype 继承的是一个 Person 对象的实例，修改 Programmer.prototype 并不会影响到 Perons&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// 优化继承
function Person(name, age){
    this.name = name;
    this.age = age;
    console.log('Person constructor');
}
Person.prototype.talk = function(){
    console.log('hello my name is:' + this.name);
};
function Programmer(){
    // 调用父类构造函数来初始化 Programmer 的属性
    Person.apply(this, arguments);
    console.log('Programmer constructor');
}
// 优化原型继承
Programmer.prototype = new Person();
Programmer.prototype.talk = function(){
    console.log('i age is:' + this.age);
};
var p = new Person('tudou', 22);
var td = new Programmer('tudou', 22);
p.talk();   // hello my name is:tudou
td.talk();  // i age is:22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的继承其实没有什么问题，但是给 Programmer.prototype 赋值的时候会实例化 Person ，如果我们只想继承 Perons.prototype 就的使用一个空的对象作为代理，在把 Programmer.prototype 指向这个代理对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;function Person(){
    console.log('Person constructor');
}
Person.prototype.talk = function(){
    console.log('hello my name is tudou');
};
function Programmer(){
    console.log('Programmer constructor');
}
// 再次优化继承
function Empey(){}
Empey.prototype = Person.prototype;
Programmer.prototype = new Empey();
Programmer.prototype.talk = function(){
    console.log('i age is 22');
};
var p = new Person();
var td = new Programmer();
p.talk();
td.talk();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 Empty 这一层对象实例作为了中转，在修改 Programmer.prototype 的属性的时候就不会影响到 Person.prototype 了&lt;/p&gt;

&lt;p&gt;写一个继承方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;(function(){
    function Person(){
        console.log('Person constructor');
    }
    Person.prototype.talk = function(){
        console.log('hello my name is tudou');
    };
    function Programmer(){
        console.log('Programmer constructor');
    }
    // 使用 extend 方法继承
    Programmer.prototype = extend(Person.prototype);
    var p = new Person();
    var td = new Programmer();
    p.talk();   // hello my name is tudou
    td.talk();  // hello my name is tudou
})();

function extend(extendObj){
    var tmpObject = function(){};
    tmpObject.prototype = extendObj;
    var res = new tmpObject();
    tmpObject.prototype = null;
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>页面中多 iframe 传值</title>
   <link href="http://tom.preston-werner.com/2014/12/29/iframe-by-value.html"/>
   <updated>2014-12-29T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2014/12/29/iframe-by-value</id>
   <content type="html">&lt;h3&gt;关于 iframe 传值&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;如果一个页面中有多个 iframe 如何做到互相调用函数和传值。js 默认自带 只能子页面调用和修改父页面的函数或变量。没有 iframe 之间的调用，那么就要想一些办法&lt;/p&gt;&lt;/blockquote&gt;

&lt;h4&gt;办法1：&lt;/h4&gt;

&lt;p&gt;当 iframe 页面加载的时候将当前的 window 对象保存在父页面的变量中&lt;/p&gt;

&lt;p&gt;父页面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var iframeObj = {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子页面（iframe）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;window.onload = function(){
    top.window.iframeObj['iframe1'] = window;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们要在一个 iframe 中调用另外一个 iframe 的时候可以这样做&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var iframe2 = top.window.iframeObj['iframe2'];
iframe2.info();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;实例&lt;/h4&gt;

&lt;iframe  frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;/resource/iframebyvalue/demo1.html&quot; width=&quot;600&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;


&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h4&gt;方法2&lt;/h4&gt;

&lt;p&gt;在子页面（iframe）里面监听 hash 的改变，通过 hash 来达到传值的目的&lt;/p&gt;

&lt;p&gt;子页面（iframe）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var hash = location.hash;
window.onload = function(){
    setInterval(function(){
        var tmpHash = location.hash;
        if(hash != tmpHash &amp;amp;&amp;amp; tmpHash != ''){
            hash = tmpHash;
            var call = hash.slice(1, hash.length);
            try{
                eval(call+&quot;()&quot;);
            }catch(e){

            }
        }
    }, 100);
};
function callInfo(){
    var iframe4 = top.window.document
    iframe4 = iframe4.getElementById('iframe4')['contentDocument'];
    iframe4.location.hash = '#callInfoRun';
}
function callInfoRun(){
    alert('我是页面 3 的 callInfo 方法');
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;实例&lt;/h4&gt;

&lt;iframe  frameborder=&quot;0&quot; scrolling=&quot;no&quot; src=&quot;/resource/iframebyvalue/demo2.html&quot; width=&quot;600&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;


&lt;p&gt;ps: 感觉第二种实用性不是太高，有一个 100 毫秒的定时器，耗性能。&lt;/p&gt;

&lt;p&gt; 测试代码下载 &lt;a href=&quot;/resource/iframebyvalue/iframe.zip&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果你还有其他的方法请加 QQ 群讨论吧 239147101&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>SVN 命令介绍</title>
   <link href="http://tom.preston-werner.com/2014/12/26/svn-command.html"/>
   <updated>2014-12-26T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2014/12/26/svn-command</id>
   <content type="html">&lt;blockquote&gt;&lt;p&gt;SVN 命令介绍&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;命令索引&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#svncheckout&quot;&gt;svn checkout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnadd&quot;&gt;svn add&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnblam&quot;&gt;svn blam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svncat&quot;&gt;svn cat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnchangelist&quot;&gt;svn changelist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svncleanup&quot;&gt;svn cleanup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svncommit&quot;&gt;svn commit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svncopy&quot;&gt;svn copy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svndelete&quot;&gt;svn delete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svndiff&quot;&gt;svn diff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnexport&quot;&gt;svn export&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnimport&quot;&gt;svn import&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svninfo&quot;&gt;svn info&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnlock&quot;&gt;svn lock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnlog&quot;&gt;svn log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnmerge&quot;&gt;svn merge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnmergeinfo&quot;&gt;svn mergeinfo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnmkdir&quot;&gt;svn mkdir&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnmove&quot;&gt;svn move&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnpropdel&quot;&gt;svn propdel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnpropedit&quot;&gt;svn propedit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnpropget&quot;&gt;svn propget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnproplist&quot;&gt;svn proplist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnpropset&quot;&gt;svn propset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnresolve&quot;&gt;svn resolve&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnresolved&quot;&gt;svn resolved&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnrevert&quot;&gt;svn revert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnstatus&quot;&gt;svn status&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnswitch&quot;&gt;svn switch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnunlock&quot;&gt;svn unlock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svnupdate&quot;&gt;svn update&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4 id=&quot;svncheckout&quot;&gt;svn checkout 从版本库签出工作副本&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;checkout (co): 从版本库签出工作副本。
使用: checkout URL[@REV]... [PATH]

  如果指定 REV，那么它确定了从 URL 首先查找的版本。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -q [--quiet]             : 不打印信息，或只打印概要信息
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --force                  : 强制操作运行
  --ignore-externals       : 忽略外部项目

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.取出一个工作拷贝到mine目录：&lt;br&gt;
$ svn checkout file:///tmp/repos/test mine&lt;/p&gt;

&lt;p&gt;2.检出两个目录到两个单独的工作拷贝：&lt;br&gt;
$ svn checkout file:///tmp/repos/test file:///tmp/repos/quiz&lt;/p&gt;

&lt;p&gt;3.检出两个目录到两个单独的工作拷贝，但是将两个目录都放到working-copies：&lt;br&gt;
$ svn checkout file:///tmp/repos/test file:///tmp/repos/quiz working-copies&lt;/p&gt;

&lt;h4 id=&quot;svnadd&quot;&gt;svn add 添加到版本库&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;add: 把文件和目录纳入版本控制，通过调度加到版本库。它们会在下一次提交时加入。
用法: add 路径...

有效选项:
  --targets ARG            : 传递文件 ARG 内容为附件参数
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --force                  : 强制操作运行
  --no-ignore              : 忽略默认值和 svn:ignore 属性
  --auto-props             : 启用自动属性
  --no-auto-props          : 关闭自动属性
  --parents                : 增加中间父目录

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.添加一个文件到工作拷贝:&lt;br&gt;
$ svn add foo.c&lt;/p&gt;

&lt;p&gt;2.当添加一个目录，svn add缺省的行为方式是递归的：&lt;br&gt;
$ svn add testdir&lt;/p&gt;

&lt;p&gt;3.你可以只添加一个目录而不包括其内容：&lt;br&gt;
$ svn add –non-recursive otherdir&lt;br&gt;
$ svn add -N otherdir&lt;/p&gt;

&lt;p&gt;4.通常情况下，命令svn add *会忽略所有已经在版本控制之下的目录，有时候，你会希望添加所有工作拷贝的未版本化文件，包括那些隐藏在深处的文件，可以使用svn add的–force递归到版本化的目录下：&lt;br&gt;
$ svn add * –force&lt;/p&gt;

&lt;h4 id=&quot;svnblam&quot;&gt;svn blam 追溯内容&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;blame (praise, annotate, ann): 输出指定文件或URL的追溯内容，包含版本和作者信息。

用法: blame 目标[@版本]...
      如果指定了版本，将从指定的版本开始查找。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -v [--verbose]           : 打印附加信息
  -g [--use-merge-history] : 从合并历史使用/显示额外信息
  --incremental            : 给予适合串联的输出
  --xml                    : 输出为 XML
  -x [--extensions] ARG    : 缺省: “-u”。当 Subversion 调用外部比较程序时，ARG 直接传给它。但是当
                             Subversion 使用缺省的内置比较实现，或者正
                             显示追溯时, ARG 可以是:
                                -u (--unified):
                                   输出三行统一上下文。
                                -b (--ignore-space-change):
                                   忽略空白数量的修改。
                                -w (--ignore-all-space):
                                   忽略所有的空白。
                                --ignore-eol-style:
                                   忽略行尾样式的改变。                            -p (--show-c-function):
                                   在比较输出中显示 C 函数名称。
  --force                  : 强制操作运行

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.如果你希望在测试版本库看到blame标记的readme.txt源代码：&lt;br&gt;
$ svn blame http://svn.red-bean.com/repos/test/readme.txt&lt;/p&gt;

&lt;h4 id=&quot;svncat&quot;&gt;svn cat 输出文件或内容&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;cat: 输出指定文件或URL的内容。
用法: cat 目标[@版本]...

      如果指定了版本，将从指定的版本开始查找。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.如果你希望不检出而察看版本库的readme.txt的内容：&lt;br&gt;
$ svn cat foo.c&lt;/p&gt;

&lt;h4 id=&quot;svnchangelist&quot;&gt;svn changelist 耦合文件与修改列表&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;changelist (cl): 耦合(或解耦)文件与修改列表 CLNAME。
使用: 1. changelist CLNAME TARGET...
      2. changelist --remove TARGET...

有效选项:
  -q [--quiet]             : 不打印信息，或只打印概要信息
  -R [--recursive]         : 向下递归，与 --depth=infinity 相同
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --remove                 : 删除修改列表耦合
  --targets ARG            : 传递文件 ARG 内容为附件参数
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;svncleanup&quot;&gt;svn cleanup 递归清理工作副本&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;cleanup: 递归清理工作副本，删除锁，继续未完成操作，等等。

用法: cleanup [路径...]

有效选项:
  --diff3-cmd ARG          : 使用 ARG 作为合并命令

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.svn cleanup没有输出，没有太多的例子，如果你没有传递PATH，会使用“.”。&lt;br&gt;
$ svn cleanup&lt;br&gt;
$ svn cleanup /path/to/working-copy&lt;/p&gt;

&lt;h4 id=&quot;svncommit&quot;&gt;svn commit 提交到版本库&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;commit (ci): 把工作副本的修改提交到版本库。
用法: commit [路径...]

     必须提供日志消息，但它可以是空的。如果没有指定 --message 或 --file
     选项，编辑器会被启动。如果有目标是锁定的或者包含锁定条目，则在成功
     提交后会被解锁。

有效选项:
  -q [--quiet]             : 不打印信息，或只打印概要信息
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --targets ARG            : 传递文件 ARG 内容为附件参数
  --no-unlock              : 不要解锁目标
  -m [--message] ARG       : 指定日志信息ARG
  -F [--file] ARG          : 从文件ARG读取日志信息
  --force-log              : 强制校验日志信息资源
  --editor-cmd ARG         : 使用 ARG 作为外部编辑器
  --encoding ARG           : 将ARG的值视为字符编码
  --with-revprop ARG       : 在新版本设置版本属性 ARG
                使用格式 name[=value]
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]
  --keep-changelists       : 不要在提交后删除修改列表

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.使用命令行提交一个包含日志信息的文件修改，当前目录（“.”）是没有说明的目标路径：&lt;br&gt;
$ svn commit -m “added howto section.”&lt;/p&gt;

&lt;p&gt;2.提交一个修改到foo.c（在命令行明确指明），并且msg文件中保存了提交信息：&lt;br&gt;
$ svn commit -F msg foo.c&lt;/p&gt;

&lt;p&gt;3.如果你希望使用在–file选项中使用在版本控制之下的文件作为参数，你需要使用–force-log选项：&lt;br&gt;
$ svn commit –file file_under_vc.txt foo.c&lt;/p&gt;

&lt;p&gt;4.提交一个已经预定要删除的文件：&lt;br&gt;
$ svn commit -m “removed file ‘c’.”&lt;/p&gt;

&lt;h4 id=&quot;svncopy&quot;&gt;svn copy 版本库中复制数据&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;copy (cp): 在工作副本或版本库中复制数据，保留历史。
用法: copy SRC[@REV]... DST

当复制多个源时，它们作为 DST 的子节点增加, DST 必须是目录。

  SRC 和 DST 可以是工作副本路径(WC)或版本库地址(URL):
    WC   -&amp;gt; WC:  复制和调度增加(包含历史)
    WC   -&amp;gt; URL: 立即提交工作副本到版本库
    URL  -&amp;gt; WC:  检出 URL 到工作副本，调度增加
    URL  -&amp;gt; URL: 完全服务器端复制；一般用于分支和标签
  所有 SRC 必须是同一类型。

警告：为了与旧版本的 Subversion 兼容，使用两个工作副本复制(WC -&amp;gt; WC)的
操作不会与版本库通信。同样地，在缺省情况下，不能从复制源到目的地传播合
并跟踪信息。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --ignore-externals       : 忽略外部项目
  --parents                : 创建中间目录
  -m [--message] ARG       : 指定日志信息ARG
  -F [--file] ARG          : 从文件ARG读取日志信息
  --force-log              : 强制校验日志信息资源
  --editor-cmd ARG         : 使用 ARG 作为外部编辑器
  --encoding ARG           : 将ARG的值视为字符编码
  --with-revprop ARG       : 在新版本设置版本属性 ARG
                使用格式 name[=value]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.拷贝工作拷贝的一个项目（只是预定要拷贝—在提交之前不会影响版本库）：&lt;br&gt;
$ svn copy foo.txt bar.txt&lt;/p&gt;

&lt;p&gt;2.拷贝你的工作拷贝的一个项目到版本库的URL（直接的提交，所以需要提供一个提交信息）：&lt;br&gt;
$ svn copy near.txt file:///tmp/repos/test/far-away.txt -m “Remote copy.”&lt;/p&gt;

&lt;p&gt;3.拷贝版本库的一个项目到你的工作拷贝（只是预定要拷贝—在提交之前不会影响版本库）：&lt;br&gt;
$ svn copy file:///tmp/repos/test/far-away near-here&lt;/p&gt;

&lt;p&gt;4.在URL之间拷贝：&lt;br&gt;
$ svn copy file:///tmp/repos/test/far-away file:///tmp/repos/test/over-there -m “remote copy.”&lt;/p&gt;

&lt;h4 id=&quot;svndelete&quot;&gt;svn delete 删除文件和目录&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;delete (del, remove, rm): 从版本库中删除文件和目录。
用法: 1、delete PATH...
      2、delete URL...

  1、每个 PATH 指定的项目会被调度到下次提交时从版本库删除。除非给出
    --keep-local 参数，工作副本中没有提交的文件和目录会被立即删除。
    如果 PATH 是未版本控制或者已修改的项目，或者包含这些项目，那么仅当
    给出 --force 参数时这些项目才会被删除。

  2、每个 URL 指定的项目会通过立即提交从版本库中删除。

有效选项:
  --force                  : 强制操作运行
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --targets ARG            : 传递文件 ARG 内容为附件参数
  -m [--message] ARG       : 指定日志信息ARG
  -F [--file] ARG          : 从文件ARG读取日志信息
  --force-log              : 强制校验日志信息资源
  --editor-cmd ARG         : 使用 ARG 作为外部编辑器
  --encoding ARG           : 将ARG的值视为字符编码
  --with-revprop ARG       : 在新版本设置版本属性 ARG
                使用格式 name[=value]
  --keep-local             : 在工作副本中保留路径

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.使用svn从工作拷贝删除文件只是预定要删除，当你提交，文件才会从版本库删除。&lt;br&gt;
$ svn delete myfile&lt;/p&gt;

&lt;p&gt;2.然而直接删除一个URL，你需要提供一个日志信息：&lt;br&gt;
$ svn delete -m “Deleting file ‘yourfile’” file:///tmp/repos/test/yourfile&lt;/p&gt;

&lt;p&gt;3.强制删除本地已修改文件的例子：&lt;br&gt;
$ svn delete –force over-there&lt;/p&gt;

&lt;h4 id=&quot;svndiff&quot;&gt;svn diff 对比查看&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;diff (di): 显示两个版本或路径的差异。
用法: 1. diff [-c M | -r N[:M]] [TARGET[@REV]...]
      2. diff [-r N[:M]] --old=OLD-TGT[@OLDREV] [--new=NEW-TGT[@NEWREV]] \
               [PATH...]
       3. diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]

  1、显示版本 REV 中 TARGET 在两个不同的版本之间的差异。TARGET 要么全是
     工作副本路径，要么全是 URL。如果 TARGET 是工作副本路径，N 默认为
     BASE，M 默认为工作副本；如果 TARGET 是 URL，N 必须指定， M 默认为 HEAD。
    “-c M” 等价于 “-r M-1:M”，“-c -M” 等价于 “-r M:M-1”。

  2、显示新旧版本中对应目标的差异。PATH 是相对于新旧目标的相对路径，
     它限制只输出这些路径上的差异。新旧目标可以是工作副本路径或地址 URL[@REV]。
     新目标默认与旧目标相同，OLDREV 默认为 N，NEWREV 默认为 M。

  3、“svn diff --old=OLD-URL[@OLDREV] --new=NEW-URL[@NEWREV]” 的简写。

     使用不加参数的 “svn diff” 显示工作副本中的本地修改。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -c [--change] ARG        : 在ARG版本(如同 -r ARG-1:ARG)作的修改
                             如果ARG为负数则等价于 -r ARG:ARG-1
  --old ARG                : 使用 ARG 作为旧目标
  --new ARG                : 使用 ARG 作为新目标
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --diff-cmd ARG           : 使用 ARG 作为比较命令
  -x [--extensions] ARG    : 缺省: “-u”。当 Subversion 调用外部比较程序时，ARG 直接传给它。但是当
                             Subversion 使用缺省的内置比较实现，或者正
                             显示追溯时, ARG 可以是:
                                -u (--unified):
                                   输出三行统一上下文。
                                -b (--ignore-space-change):
                                   忽略空白数量的修改。
                                -w (--ignore-all-space):
                                   忽略所有的空白。
                                --ignore-eol-style:
                                   忽略行尾样式的改变。                            -p (--show-c-function):
                                   在比较输出中显示 C 函数名称。
  --no-diff-deleted        : 不要输出删除文件造成的差异
  --notice-ancestry        : 比较差异时提示原始信息
  --summarize              : 显示结果的概要
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]
  --force                  : 强制操作运行
  --xml                    : 输出为 XML

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.比较BASE和你的工作拷贝（svn diff最经常的用法）：&lt;br&gt;
$ svn diff COMMITTERS&lt;/p&gt;

&lt;p&gt;2.查看文件COMMITTERS在修订版本9115修改的内容：&lt;br&gt;
$ svn diff -c 9115 COMMITTERS&lt;/p&gt;

&lt;p&gt;3.察看你的工作拷贝对旧的修订版本的修改：&lt;br&gt;
$ svn diff -r 3900 COMMITTERS&lt;/p&gt;

&lt;p&gt;4.使用“@”语法与修订版本3000和35000比较：&lt;br&gt;
$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500&lt;/p&gt;

&lt;p&gt;5.使用范围符号来比较修订版本3000和3500（在这种情况下只能传递一个URL）：&lt;br&gt;
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS&lt;/p&gt;

&lt;p&gt;6.使用范围符号比较修订版本3000和3500trunk中的所有文件：&lt;br&gt;
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk&lt;/p&gt;

&lt;p&gt;7.使用范围符号比较修订版本3000和3500trunk中的三个文件：&lt;br&gt;
$ svn diff -r 3000:3500 –old http://svn.collab.net/repos/svn/trunk COMMITTERS README HACKING&lt;/p&gt;

&lt;p&gt;8.如果你有工作拷贝，你不必输入这么长的URL：&lt;br&gt;
$ svn diff -r 3000:3500 COMMITTERS&lt;/p&gt;

&lt;h4 id=&quot;svnexport&quot;&gt;svn export 导出&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;export: 产生一个无版本控制的目录树副本。
用法: 1、export [-r REV] URL[@PEGREV] [PATH]
      2、export [-r REV] PATH1[@PEGREV] [PATH2]

  1、从 URL 指定的版本库，导出一个干净的目录树到 PATH。如果有指定
     REV 的话，内容即为该版本的，否则就是 HEAD 版本。如果 PATH
     被省略的话，URL的最后部份会被用来当成本地的目录名称。

  2、在工作副本中，从指定的 PATH1 导出一个干净的目录树到 PATH2。如果
     有指定 REV 的话，会从指定的版本导出，否则从工作副本导出。如果
     PATH2 被省略的话，PATH1 的最后部份会被用来当成本地的目录名称。
     如果没有指定 REV 的话，所有的本地修改都保留，但是未纳入版本控制
     的文件不会被复制。

     如果指定了 PEGREV ，将从指定的版本本开始查找。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -q [--quiet]             : 不打印信息，或只打印概要信息
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --force                  : 强制操作运行
  --native-eol ARG         : 使用非标准的 EOL 标记
                系统中立的文件标记 svn:eol-style 属性取值为 “native”。
                ARG 可以是以下之一“LF”，“CR”，“CRLF”
  --ignore-externals       : 忽略外部项目

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.从你的工作拷贝导出（不会打印每一个文件和目录）：&lt;br&gt;
$ svn export a-wc my-export&lt;/p&gt;

&lt;p&gt;2.从版本库导出目录（打印所有的文件和目录）：&lt;br&gt;
$ svn export file:///tmp/repos my-export&lt;/p&gt;

&lt;h4 id=&quot;svnimport&quot;&gt;svn import 纳入版本控制&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;import: 将未纳入版本控制的文件或目录树提交到版本库。
用法: import [PATH] URL

  递归地提交 PATH 的副本至 URL。
  如果省略 PATH，则默认为 “.”。
  父目录会根据需要在版本库内创建。
  如果 PATH 是目录，则其下的内容直接加入到 URL 指定的位置内。
  如果使用了 “--force”，那么不能纳入版本控制的项目，例如设备文件，管道等，会被忽略。

有效选项:
  -q [--quiet]             : 不打印信息，或只打印概要信息
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --auto-props             : 启用自动属性
  --force                  : 强制操作运行
  --no-auto-props          : 关闭自动属性
  -m [--message] ARG       : 指定日志信息ARG
  -F [--file] ARG          : 从文件ARG读取日志信息
  --force-log              : 强制校验日志信息资源
  --editor-cmd ARG         : 使用 ARG 作为外部编辑器
  --encoding ARG           : 将ARG的值视为字符编码
  --with-revprop ARG       : 在新版本设置版本属性 ARG
                使用格式 name[=value]
  --no-ignore              : 忽略默认值和 svn:ignore 属性

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.这将本地目录myproj导入到版本库的trunk/misc，trunk/misc在导入之前不需要存在—svn import会递归的为你创建目录。&lt;br&gt;
$ svn import -m “New import” myproj http://svn.red-bean.com/repos/trunk/misc&lt;/p&gt;

&lt;p&gt;2.需要知道这样不会在版本库创建目录myproj，如果你希望这样，请在URL后添加myproj：&lt;br&gt;
$ svn import -m “New import” myproj http://svn.red-bean.com/repos/trunk/misc/myproj&lt;/p&gt;

&lt;h4 id=&quot;svninfo&quot;&gt;svn info 显示本地或远程条目的信息&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;info: 显示本地或远程条目的信息。
用法: info [TARGET[@REV]...]

  显示每个 TARGET 的信息 (默认: “.”)。
  TARGET 可以是工作副本中的路径或版本库中的 URL。REV 指定从哪个
  版本开始查找目标。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -R [--recursive]         : 向下递归，与 --depth=infinity 相同
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --targets ARG            : 传递文件 ARG 内容为附件参数
  --incremental            : 给予适合串联的输出
  --xml                    : 输出为 XML
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.svn info会展示工作拷贝所有项目的所有有用信息，它会显示文件的信息：&lt;br&gt;
$ svn info foo.c&lt;/p&gt;

&lt;p&gt;2.它也会展示目录的信息：&lt;br&gt;
$ svn info vendors&lt;/p&gt;

&lt;p&gt;3.svn info也可以针对URL操作：&lt;br&gt;
$ svn info http://svn.red-bean.com/repos/test/readme.doc&lt;/p&gt;

&lt;h4 id=&quot;svnlock&quot;&gt;svn lock 锁定版本库中的路径&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;lock: 锁定版本库中的路径，使得其他用户不能向其提交修改。
用法: lock TARGET...

     使用 --force 选项可以从其他用户或工作副本窃取到锁。

有效选项:
  --targets ARG            : 传递文件 ARG 内容为附件参数
  -m [--message] ARG       : 指定加锁注释ARG
  -F [--file] ARG          : 从文件 ARG 读取加锁注释
  --force-log              : 强制校验锁定注释源
  --encoding ARG           : 将ARG的值视为字符编码
  --force                  : 强制操作运行

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.在工作拷贝锁定两个文件：&lt;br&gt;
$ svn lock tree.jpg house.jpg&lt;/p&gt;

&lt;p&gt;2.锁定工作拷贝的一个被其它用户锁定的文件：&lt;br&gt;
$ svn lock tree.jpg&lt;br&gt;
$ svn lock –force tree.jpg&lt;/p&gt;

&lt;p&gt;3.没有工作拷贝的情况下锁定文件：&lt;br&gt;
$ svn lock http://svn.red-bean.com/repos/test/tree.jpg&lt;/p&gt;

&lt;h4 id=&quot;svnlog&quot;&gt;svn log 查看日志&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;log: 显示一组版本与/或文件的提交日志信息。
用法: 1、log [PATH]
      2、log URL[@REV] [PATH...]

  1、显示本地 PATH (默认: “.”) 的日志信息。默认的版本范围是 BASE:1。

  2、显示 URL 中 PATH (默认: “.”) 的日志信息。如果指定了 REV，就从 REV
     开始查找 URL，版本范围是 REV:1。否则就从 HEAD 开始查找 URL，版本范围
     是 HEAD:1。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -q [--quiet]             : 不打印信息，或只打印概要信息
  -v [--verbose]           : 打印附加信息
  -g [--use-merge-history] : 从合并历史使用/显示额外信息
  -c [--change] ARG        : 版本 ARG 引起的改变
  --targets ARG            : 传递文件 ARG 内容为附件参数
  --stop-on-copy           : 查看历史不要跨越不同的副本
  --incremental            : 给予适合串联的输出
  --xml                    : 输出为 XML
  -l [--limit] ARG         : 日值项最大值
  --with-all-revprops      : 获取所有版本属性
  --with-no-revprops       : 没有找回版本属性
  --with-revprop ARG       : 获取版本属性 ARG

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.查看最近3个版本日志&lt;br&gt;
svn log [PATH] -v -l3&lt;/p&gt;

&lt;p&gt;2.查看某两个版本，用来对比&lt;br&gt;
svn log -r 14:15&lt;/p&gt;

&lt;p&gt;3.日志放入文件&lt;br&gt;
$ svn log -r 14 &gt; mylog&lt;br&gt;
$ svn log -r 19 &gt;&gt; mylog&lt;br&gt;
$ svn log -r 27 &gt;&gt; mylog&lt;br&gt;
$ cat mylog&lt;/p&gt;

&lt;p&gt;或者&lt;br&gt;
$ svn log –incremental -r 14 &gt; mylog&lt;br&gt;
$ svn log –incremental -r 19 &gt;&gt; mylog&lt;br&gt;
$ svn log –incremental -r 27 &gt;&gt; mylog&lt;br&gt;
$ cat mylog&lt;/p&gt;

&lt;h4 id=&quot;svnmerge&quot;&gt;svn merge 将两个源差异应用至工作副本&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;merge: 将两个源差异应用至工作副本。
用法:  1. merge sourceURL1[@N] sourceURL2[@M] [WCPATH]
       2. merge sourceWCPATH1@N sourceWCPATH2@M [WCPATH]
       3. merge [-c M[,N...] | -r N:M ...] SOURCE[@REV] [WCPATH]

  1、第一种形式中，源 URL 的版本 N 与 M 作为比较的来源。如果没有指定版本，默认
     为 HEAD。

  2、在第二种形式中，两个源工作副本路径对应的版本库中的 URL 作为比较的来源。这
     里必须指定版本。

  3、第三种形式中，SOURCE 可为 URL 或工作副本中的路径(后者会使用版本库中对应
     的 URL)。比较版本为 REV 的 SOURCE，就像它在版本 N 到 M 存在一样。如果没
     有给出 REV，默认为 HEAD。选项 “-c M” 等价于 “-r :M”，“-c -M” 与之
     相反，等价于 “-r M:”。如果没有指定版本范围，默认为 0:REV。可以指定
     多个 “-c” 或 “-r”，并且可以混合使用向前范围或向后范围。

  WCPATH 是接收修改的工作副本路径。如果省略了 WCPATH，默认为 “.”，除非来源中
  有与当前目录内同名的文件，这时修改会直接应用至该文件。

  注意:  Subversion 只有当两个合并源有继承关系的时候才会内部跟踪合并操作的源数
  据 -- 即如果第一个合并源是第二个的祖先，或者相反。在上述的第三种形式中，已经
  保证了满足条件。选项 --ignore-ancestry 忽略继承关系，强制 Subversion 认为合并
  源之间没有关系，不跟踪本次合并。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -c [--change] ARG        : 在ARG版本(如同 -r ARG-1:ARG)作的修改
                             如果ARG为负数则等价于 -r ARG:ARG-1
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --force                  : 强制操作运行
  --dry-run                : 尝试操作但没有修改
  --diff3-cmd ARG          : 使用 ARG 作为合并命令
  --record-only            : 标记版本为已合并(使用 -r 参数)
  -x [--extensions] ARG    : 缺省: “-u”。当 Subversion 调用外部比较程序时，ARG 直接传给它。但是当
                             Subversion 使用缺省的内置比较实现，或者正
                             显示追溯时, ARG 可以是:
                                -u (--unified):
                                   输出三行统一上下文。
                                -b (--ignore-space-change):
                                   忽略空白数量的修改。
                                -w (--ignore-all-space):
                                   忽略所有的空白。
                                --ignore-eol-style:
                                   忽略行尾样式的改变。                            -p (--show-c-function):
                                   在比较输出中显示 C 函数名称。
  --ignore-ancestry        : 合并时忽略原始信息
  --accept ARG             : 指定自动解决冲突动作
                            ('postpone', 'base', 'mine-conflict',
                             'theirs-conflict', 'mine-full', 'theirs-full',
                             'edit', 'launch')
  --reintegrate            : 批量合并所有源 URL 中未合并的修改

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.将一个分支合并回主干（假定你有一份主干的工作拷贝，分支在修订版本250创建）：&lt;br&gt;
$ svn merge -r 250:HEAD http://svn.red-bean.com/repos/branches/my-branch&lt;/p&gt;

&lt;p&gt;2.如果你的分支在修订版本23，你希望将主干的修改合并到分支，你可以在你的工作拷贝的分支上这样做：&lt;br&gt;
$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors&lt;/p&gt;

&lt;p&gt;3.合并一个单独文件的修改：&lt;br&gt;
$ svn merge -r 30:31 thhgttg.txt&lt;/p&gt;

&lt;h4 id=&quot;svnmergeinfo&quot;&gt;svn mergeinfo 显示合并的相关信息&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;mergeinfo: 显示合并的相关信息。
用法: mergeinfo SOURCE[@REV] [TARGET[@REV]]

  显示 SOURCE 与 TARGET(默认为 “.”) 之间的合并(或潜在合并)信息。如果没有
  提供选项 --show-revs，那么就显示已经从 SOURCE 合并到 TARGET 的版本。否
  则就显示选项 --show-revs 指定的信息。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  --show-revs ARG          : 指定显示哪个版本集合
                             ('merged', 'eligible')

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.查看分支目录合并信息&lt;br&gt;
$ svn mergeinfo branches/test&lt;/p&gt;

&lt;h4 id=&quot;svnmkdir&quot;&gt;svn mkdir 创建纳入版本控制的新目录&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;mkdir: 创建纳入版本控制的新目录。
用法: 1、mkdir PATH...
      2、mkdir URL...

  创建版本控制的目录。

  1、每个以工作副本 PATH 指定的目录，都会在本地创建，并且加入增加
     调度，直到下次提交。

  2、每个以 URL 指定的目录，都会通过立即提交在版本库中创建。

  在这两个情况下，所有的中间目录都必须事先存在，
  除非使用选项 --parents。

有效选项:
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --parents                : 创建中间目录
  -m [--message] ARG       : 指定日志信息ARG
  -F [--file] ARG          : 从文件ARG读取日志信息
  --force-log              : 强制校验日志信息资源
  --editor-cmd ARG         : 使用 ARG 作为外部编辑器
  --encoding ARG           : 将ARG的值视为字符编码
  --with-revprop ARG       : 在新版本设置版本属性 ARG
                使用格式 name[=value]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.在工作副本创建一个目录：&lt;br&gt;
$ svn mkdir newdir&lt;/p&gt;

&lt;h4 id=&quot;svnmove&quot;&gt;svn move 移动或改名文件或目录&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;move (mv, rename, ren): 在工作副本或版本库中移动或改名文件或目录。
用法: move SRC... DST

当移动多个源时，它们作为 DST 的子节点增加，DST 必须是目录。

  注意: 本子命令等同于先 “copy”，然后 “delete”。
  注意: 此命令中 --revision 选项没有作用，已经淘汰。

  SRC 可同时为工作副本(WC) 路径或 URL:
    WC  -&amp;gt; WC  :  移动并加入新增调度 (连同历史记录)
    URL -&amp;gt; URL :  完全是服务器端更名。
  所有 SRC 必须是同一类型。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --force                  : 强制操作运行
  --parents                : 创建中间目录
  -m [--message] ARG       : 指定日志信息ARG
  -F [--file] ARG          : 从文件ARG读取日志信息
  --force-log              : 强制校验日志信息资源
  --editor-cmd ARG         : 使用 ARG 作为外部编辑器
  --encoding ARG           : 将ARG的值视为字符编码
  --with-revprop ARG       : 在新版本设置版本属性 ARG
                使用格式 name[=value]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.移动工作拷bede一个文件：&lt;br&gt;
$ svn move foo.c bar.c&lt;/p&gt;

&lt;p&gt;2.移动工作副本的一些文件到子目录：&lt;br&gt;
$ svn move baz.c bat.c qux.c src&lt;/p&gt;

&lt;h4 id=&quot;svnpropdel&quot;&gt;svn propdel 删除目录、文件或版本的属性&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;propdel (pdel, pd): 删除目录、文件或版本的属性。
用法: 1、propdel PROPNAME [PATH...]
      2、propdel PROPNAME --revprop -r REV [URL]

  1、删除工作副本中纳入版本管理的文件或目录的属性。
  2、删除版本库中版本的属性。TARGET只用来判断访问哪个版本库。

有效选项:
  -q [--quiet]             : 不打印信息，或只打印概要信息
  -R [--recursive]         : 向下递归，与 --depth=infinity 相同
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  --revprop                : 在版本属性上操作(使用-r参数)
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.删除你的工作副本中一个文件的一个属性：&lt;br&gt;
$ svn propdel svn:mime-type some-script&lt;/p&gt;

&lt;p&gt;2.删除一个修订版本的属性：&lt;br&gt;
$ svn propdel –revprop -r 26 release-date&lt;/p&gt;

&lt;h4 id=&quot;svnpropedit&quot;&gt;svn propedit 编辑属性&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;propedit (pedit, pe): 使用外部编辑器编辑属性。
用法: 1、propedit PROPNAME TARGET...
      2、propedit PROPNAME --revprop -r REV [TARGET]

  1、编辑工作副本或者版本库中受版本控制的属性。
  2、编辑版本库中指定版本的未版本控制的远程属性。
     TARGET 只用来判断访问哪一个版本库。

参见 “svn help propset” 以获得更多设置属性的信息。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  --revprop                : 在版本属性上操作(使用-r参数)
  -m [--message] ARG       : 指定日志信息ARG
  -F [--file] ARG          : 从文件ARG读取日志信息
  --force-log              : 强制校验日志信息资源
  --editor-cmd ARG         : 使用 ARG 作为外部编辑器
  --encoding ARG           : 将ARG的值视为字符编码
  --with-revprop ARG       : 在新版本设置版本属性 ARG
                使用格式 name[=value]
  --force                  : 强制操作运行

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.svn propedit对修改多个值的属性非常简单：&lt;br&gt;
$ svn propedit svn:keywords foo.c&lt;/p&gt;

&lt;h4 id=&quot;svnpropget&quot;&gt;svn propget 显示目录、文件或版本的属性取值&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;propget (pget, pg): 显示目录、文件或版本的属性取值。
用法:  1、propget PROPNAME [TARGET[@REV]...]
       2、propget PROPNAME --revprop -r REV [URL]

  1、显示版本控制的属性。REV 指定从哪个版本开始查找目标。
  2、显示版本库中版本的未版本控制的远程属性。
     只用来判断访问哪个版本库。

  本子命令默认会在属性内容加上额外的换行符，得到美观的输出。另外，
  当同时处理多个路径时，每一个属性内容会在开头增加上它所对应的路径。
  使用 --strict 选项可以关闭这些美化行为 (它很有用，例如将二进制属
  性内容重定向到一个文件，但是仅用于单一目标的非递归操作)。

有效选项:
  -v [--verbose]           : 打印附加信息
  -R [--recursive]         : 向下递归，与 --depth=infinity 相同
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  --revprop                : 在版本属性上操作(使用-r参数)
  --strict                 : 使用严格的语法
  --xml                    : 输出为 XML
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.检查工作副本的一个文件的一个属性：&lt;br&gt;
$ svn propget svn:keywords foo.c&lt;/p&gt;

&lt;p&gt;2.对于修订版本属性相同：&lt;br&gt;
$ svn propget svn:log –revprop -r 20&lt;/p&gt;

&lt;h4 id=&quot;svnproplist&quot;&gt;svn proplist 列出目录、文件或版本的所有属性&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;proplist (plist, pl): 列出目录、文件或版本的所有属性。
用法:  1、proplist [TARGET[@REV]...]
       2、proplist --revprop -r REV [TARGET]

  1、显示目标的属性。REV 指定从哪个版本开始查找目标。
  2、列出版本库中版本的属性。TARGET 只用来判断访问哪个版本库。

有效选项:
  -v [--verbose]           : 打印附加信息
  -R [--recursive]         : 向下递归，与 --depth=infinity 相同
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --revprop                : 在版本属性上操作(使用-r参数)
  --xml                    : 输出为 XML
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.你可以使用proplist看到你工作拷贝的属性：&lt;br&gt;
$ svn proplist foo.c&lt;/p&gt;

&lt;p&gt;2.使用 –verbose参数，将更清楚的显示工作拷贝的属性：&lt;br&gt;
$ svn proplist –verbose foo.c&lt;/p&gt;

&lt;h4 id=&quot;svnpropset&quot;&gt;svn propset 设定目录、文件或版本的属性&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;propset (pset, ps): 设定目录、文件或版本的属性。
用法: 1. propset PROPNAME PROPVAL PATH...
      2. propset PROPNAME --revprop -r REV PROPVAL [TARGET]

  1、在工作副本中修改一个受版本控制的属性。
  2、在版本库的版本中修改一个非版本控制的属性。
     (TARGET 只用来判断访问哪一个版本库。)

  可以使用选项 --file 来代替 PROPVAL 赋值。

  注意: svn 除了能存储任意属性外，还识别以下专用的版本控制属性:
    svn:ignore     - 以换行符隔开的文件忽略模式列表。
    svn:keywords   - 将被展开的关键字。有效的关键字为。
      URL, HeadURL             - 此对象最新版本的 URL。
      Author, LastChangedBy    - 最后修改文件的人。
      Date, LastChangedDate    - 此对象最后修改的日期。
      Rev, Revision,           - 此对象最后修改的版本号。
      LastChangedRevision
      Id                       - 前四个关键字的压缩摘要。
      Header                   - 与 Id 类似，只是包含完整的 URL。
    svn:executable   - 如果存在此属性则设置文件为可执行的。
      使用 “svn propdel svn:executable PATH...” 清除。
    svn:eol-style    - “native”，“LF”，“CR”，“CRLF” 之一。
    svn:mime-type    - 文件的媒体类型。用以决定是否该合并该文件，
      以及 Apache 如何处理它。媒体类型以“text/”开头(或是没有指
      定媒体类型)的文件会被视为纯文本文件，否则就是二进制数据。
    svn:externals    - 以换行符隔开的模块说明列表，每项都由一个
      相对路径、可选的版本标志、一个 URL 组成。这三个元素的顺序实现
      不同的行为。Subversion 1.4 和早期的版本仅支持下列格式，并且 URL
      中不能有 peg 版本：
        foo             http://example.com/repos/zig
        foo/bar -r 1234 http://example.com/repos/zag
      Subversion 1.5 和更高的版本支持以上格式，以及下列格式，URL 中可以有
      peg 版本：
                http://example.com/repos/zig foo
        -r 1234 http://example.com/repos/zig foo/bar
      Subversion 1.5 和更高的版本在上述格式中支持相对 URL，在用 URL 开始用
      下述字符串之一来指示：
        ../  相对于外部引用的父目录
        ^/   相对于版本库的根
        //   相对于方案
        /    相对于服务器根
      相对路径“relative_path relative_path”这种不明确的格式来自
      “relative_url relative_path”和 peg 版本支持。
    svn:needs-lock - 此属性表明文件在修改前应该加锁。
      如果没有加锁，则此文件在工作副本中应被设为只读。使用
      “svn propdel svn:needs-lock PATH...” 清除。

    svn:keywords, svn:executable, svn:eol-style, svn:mime-type 以及
    svn:needs-lock 属性不能设置在目录上。使用非递归选项(-N)在目录上
    设置这些属性时会失败，递归操作时只会作用于指定目录中的文件子孙上。

有效选项:
  -F [--file] ARG          : 从文件 ARG 读取属性值
  --encoding ARG           : 将ARG的值视为字符编码
  -q [--quiet]             : 不打印信息，或只打印概要信息
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  --targets ARG            : 传递文件 ARG 内容为附件参数
  -R [--recursive]         : 向下递归，与 --depth=infinity 相同
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --revprop                : 在版本属性上操作(使用-r参数)
  --force                  : 强制操作运行
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.给文件设置MIME type属性:&lt;br&gt;
$ svn propset svn:mime-type image/jpeg foo.jpg&lt;/p&gt;

&lt;p&gt;2.在UNIX系统，如果你希望一个文件设置执行权限：&lt;br&gt;
$ svn propset svn:executable ON somescript&lt;/p&gt;

&lt;p&gt;3.或许为了合作者的利益你有一个内部的属性设置：&lt;br&gt;
$ svn propset owner sally foo.c&lt;/p&gt;

&lt;p&gt;4.如果你在特定修订版本的日志信息里有一些错误，并且希望修改，可以使用–revprop设置svn:log为新的日志信息： &lt;br&gt;
$ svn propset –revprop -r 25 svn:log “Journaled about trip to New York.”&lt;/p&gt;

&lt;h4 id=&quot;svnresolve&quot;&gt;svn resolve 解决工作副本中目录或文件的冲突&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;resolve: 解决工作副本中目录或文件的冲突。
用法: resolve --accept=ARG [PATH...]

  注意:  当前需要选项 --accept 。

有效选项:
  --targets ARG            : 传递文件 ARG 内容为附件参数
  -R [--recursive]         : 向下递归，与 --depth=infinity 相同
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --accept ARG             : 指定自动解决冲突动作的源
                            ('base', 'working', 'mine-conflict',
                             'theirs-conflict', 'mine-full', 'theirs-full')

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1、svn update后，1.txt文件出现冲突，选择base版本，即1.txt.rOld作为最后提交的版本&lt;br&gt;
$ svn resolve –accept base&lt;/p&gt;

&lt;p&gt;2.手工修改1.txt文件，然后将当前拷贝即1.txt作为最后提交的版本&lt;br&gt;
$ svn resolve –accept working 1.txt&lt;/p&gt;

&lt;p&gt;3.使用1.txt.rNew作为最后提交的版本&lt;br&gt;
$ svn resolve –accept theirs-full 1.txt&lt;/p&gt;

&lt;p&gt;4.使用1.txt.mine作为最后提交的版本 &lt;br&gt;
$ svn resolve –accept mine-full 1.txt&lt;/p&gt;

&lt;p&gt;5.使用1.txt.mine作为最后提交的版本 &lt;br&gt;
$ svn resolve –accept theirs-conflict 1.txt&lt;/p&gt;

&lt;h4 id=&quot;svnresolved&quot;&gt;svn resolved 删除工作副本中目录或文件的“冲突”状态&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;resolved: 删除工作副本中目录或文件的“冲突”状态。
用法: resolved PATH...

  注意: 本子命令不会依语法来解决冲突或是删除冲突标记；它只是删除冲突相关的
        附加文件，让 PATH 可以被再次提交。它已经过时，被
        “svn resolve --accept working”取代。

有效选项:
  --targets ARG            : 传递文件 ARG 内容为附件参数
  -R [--recursive]         : 向下递归，与 --depth=infinity 相同
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  -q [--quiet]             : 不打印信息，或只打印概要信息

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1、当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。&lt;br&gt;
$ svn resolved foo.c&lt;/p&gt;

&lt;h4 id=&quot;svnrevert&quot;&gt;svn revert 将工作副本文件恢复到原始版本&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;revert: 将工作副本文件恢复到原始版本(恢复大部份的本地修改)。
用法: revert PATH...

  注意: 本子命令不会访问网络，它解除任何冲突的状态。
  但是，它不恢复被删除的目录。

有效选项:
  --targets ARG            : 传递文件 ARG 内容为附件参数
  -R [--recursive]         : 向下递归，与 --depth=infinity 相同
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1、丢弃对一个文件的修改：&lt;br&gt;
$ svn revert foo.c&lt;/p&gt;

&lt;p&gt;2.如果你希望恢复一整个目录的文件，可以使用–recursive选项：&lt;br&gt;
$ svn revert –recursive .&lt;/p&gt;

&lt;p&gt;3.最后，你可以取消预定的操作：&lt;br&gt;
$ svn add mistake.txt whoops&lt;br&gt;
$ svn revert mistake.txt whoops&lt;/p&gt;

&lt;h4 id=&quot;svnstatus&quot;&gt;svn status 显示工作副本中目录与文件的状态&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;status (stat, st): 显示工作副本中目录与文件的状态。
用法: status [PATH...]

  未指定参数时，只显示本地修改的条目(没有网络访问)。
  使用 -q 时，只显示本地修改条目的摘要信息。
  使用 -u 时，增加工作版本和服务器上版本过期信息。
  使用 -v 时，显示每个条目的完整版本信息。

  输出的前七栏各占一个字符宽度:
    第一栏: 表示一个项目是增加、删除，还是修改
      “ ” 无修改
      “A” 增加
      “C” 冲突
      “D” 删除
      “I” 忽略
      “M” 改变
      “R” 替换
      “X” 未纳入版本控制的目录，被外部引用的目录所创建
      “?” 未纳入版本控制
      “!” 该项目已遗失(被非 svn 命令删除)或不完整
      “~” 版本控制下的项目与其它类型的项目重名
    第二栏: 显示目录或文件的属性状态
      “ ” 无修改
      “C” 冲突
      “M” 改变
    第三栏: 工作副本目录是否被锁定
      “ ” 未锁定
      “L” 锁定
    第四栏: 已调度的提交是否包含副本历史
      “ ” 没有历史
      “+” 包含历史
    第五栏: 该条目相对其父目录是否已切换，或者是外部引用的文件
      “ ” 正常
      “S” 已切换
      “X” 被外部引用创建的文件
    第六栏: 版本库锁定标记
      (没有 -u)
      “ ” 没有锁定标记
      “K” 存在锁定标记
      (使用 -u)
      “ ” 没有在版本库中锁定，没有锁定标记
      “K” 在版本库中被锁定，存在锁定标记
      “O” 在版本库中被锁定，锁定标记在一些其他工作副本中
      “T” 在版本库中被锁定，存在锁定标记但已被窃取
      “B” 没有在版本库中被锁定，存在锁定标记但已被破坏
    第七栏: 项目冲突标记
      “ ” 正常
      “C” 树冲突
    如果项目包含于树冲突之中，在项目状态行后会附加行，说明冲突的种类。

  是否过期的信息出现的位置是第九栏(与 -u 并用时):
      “*” 服务器上有更新版本
      “ ” 工作副本是最新版的

  剩余的栏位皆为变动宽度，并以空白隔开:
    工作版本号(使用 -u 或 -v 时)
    最后提交的版本与最后提交的作者(使用 -v 时)
    工作副本路径总是最后一栏，所以它可以包含空白字符。

  范例输出:
    svn status wc
     M     wc/bar.c
    A  +   wc/qax.c

    svn status -u wc
     M           965    wc/bar.c
           *     965    wc/foo.c
    A  +         965    wc/qax.c
    Status against revision:   981

    svn status --show-updates --verbose wc
     M           965       938 kfogel       wc/bar.c
           *     965       922 sussman      wc/foo.c
    A  +         965       687 joe          wc/qax.c
                 965       687 joe          wc/zig.c
    Status against revision:   981

    svn status
     M      wc/bar.c
    !     C wc/qaz.c
          &amp;gt;   local missing, incoming edit upon update
    D       wc/qax.c

有效选项:
  -u [--show-updates]      : 显示更新信息
  -v [--verbose]           : 打印附加信息
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --no-ignore              : 忽略默认值和 svn:ignore 属性
  --incremental            : 给予适合串联的输出
  --xml                    : 输出为 XML
  --ignore-externals       : 忽略外部项目
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;svnswitch&quot;&gt;svn switch 更新工作副本至不同的URL&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;switch (sw): 更新工作副本至不同的URL。
用法:  1、switch URL[@PEGREV] [PATH]
       2、switch --relocate FROM TO [PATH...]

  1、更新工作副本，切换到同一版本库中的新 URL。其行为跟 “svn update” 很像，
     也是将工作副本切换到同一版本库中某个分支或者标签的方法。PEGREV 决定从，
     哪个版本查找目标。

     如果使用了 “--force” 选项，在工作副本中未版本控制的障碍路径，不会自动
     导致失败。如果障碍路径与版本库中的对应路径类型相同(文件或目录)，它将成
     为受版本控制的路径，但是内容不改变。它意味着障碍路径的子孙，如果也是障
     碍路径，那么也会受版本控制。对于障碍路径中的文件，如果与版本库内的不同，
     将视为工作副本发生本地修改。版本库中的所有属性都应用于障碍路径。

     使用 “--set-depth” 选项设置此操作目标的工作副本之新深度。

  2、重写工作副本的 URL 元数据，以反映单纯的 URL 改变。当版本库的根 URL 改
     变(比如方案或者主机名称变动)，但是工作副本仍旧对应同一版本库的同一目录
     时，使用这个命令更新工作副本与档案库的对应关系。

  参见 “svn help update” 以获取报告执行动作的字符列表。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --set-depth ARG          : 设置工作副本的新深度为 ARG(“exclude”，“empty”，“files”，“immediates”，
                            或“infinity”)
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --diff3-cmd ARG          : 使用 ARG 作为合并命令
  --relocate               : 通过URL改写重新定位
  --ignore-externals       : 忽略外部项目
  --force                  : 强制操作运行
  --accept ARG             : 指定自动解决冲突动作
                            ('postpone', 'base', 'mine-conflict',
                             'theirs-conflict', 'mine-full', 'theirs-full',
                             'edit', 'launch')

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1、如果你目前所在目录vendors分支到vendors-with-fix，你希望转移到那个分支：&lt;br&gt;
$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .&lt;/p&gt;

&lt;p&gt;2.为了跳转回来，只需要提供最初取出工作拷贝的版本库URL：&lt;br&gt;
$ svn switch http://svn.red-bean.com/repos/trunk/vendors .&lt;/p&gt;

&lt;h4 id=&quot;svnunlock&quot;&gt;svn unlock 解除工作副本或URL的锁定&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;unlock: 解除工作副本或URL的锁定。
用法: unlock TARGET...

    使用 --force 终止锁定。

有效选项:
  --targets ARG            : 传递文件 ARG 内容为附件参数
  --force                  : 强制操作运行

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.解锁工作拷贝中的两个文件：&lt;br&gt;
$ svn unlock tree.jpg house.jpg&lt;/p&gt;

&lt;p&gt;2.解锁工作拷贝的一个被其他用户锁定的文件：&lt;br&gt;
$ svn unlock tree.jpg&lt;/p&gt;

&lt;p&gt;3.没有工作拷贝时解锁一个文件：&lt;br&gt;
$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg&lt;/p&gt;

&lt;h4 id=&quot;svnupdate&quot;&gt;svn update 将版本库的修改合并到工作副本中&lt;/h4&gt;


&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;update (up): 将版本库的修改合并到工作副本中。
用法: update [PATH...]

  如果没有指定版本，则将工作副本更新到 HEAD 版本。否则同步到 -r 选项所
  指定的版本。

  每更新一项就输出一行信息，使用首字符来报告执行的动作。这些字符的含义是: 

    A  已添加
    D  已删除
    U  已更新
    C  合并冲突
    G  合并成功
    E  已存在

  第一列字符表示文件内容更新，第二列表示文件属性更新。第三列中的字符“B”
  表示此文件上的锁被终止或窃取。

  如果使用了 “--force” 选项，在工作副本中未版本控制的障碍路径，不会自动
  导致签出失败。 如果障碍路径与版本库中的对应路径类型相同(文件或目录),它
  将成为受版本控制的路径，但是内容不改变。它意味着障碍路径的子孙，如果也
  是障碍路径，那么也将受版本控制。对于障碍路径中的文件，如果与版本库内的
  不同，将视为工作副本发生本地修改。版本库中的所有属性都应用于障碍路径。
  用第一列字符 “E” 来报告障碍路径。

  使用“--set-depth”选项设置此操作目标的工作副本之新深度。

有效选项:
  -r [--revision] ARG      : ARG (一些命令也接受ARG1:ARG2范围)
                             版本参数可以是如下之一:
                                NUMBER       版本号
                                '{' DATE '}' 在指定时间以后的版本
                                'HEAD'       版本库中的最新版本
                                'BASE'       工作副本的基线版本
                                'COMMITTED'  最后提交或基线之前
                                'PREV'       COMMITTED的前一版本
  -N [--non-recursive]     : 过时；尝试 --depth=files 或 --depth=immediates
  --depth ARG              : 受深度参数 ARG(“empty”，“files”，“immediates”，或“infinity”) 约束的操作
  --set-depth ARG          : 设置工作副本的新深度为 ARG(“exclude”，“empty”，“files”，“immediates”，
                            或“infinity”)
  -q [--quiet]             : 不打印信息，或只打印概要信息
  --diff3-cmd ARG          : 使用 ARG 作为合并命令
  --force                  : 强制操作运行
  --ignore-externals       : 忽略外部项目
  --changelist ARG         : 只能对修改列表 ARG 成员操作
                             [aliases: --cl]
  --editor-cmd ARG         : 使用 ARG 作为外部编辑器
  --accept ARG             : 指定自动解决冲突动作
                            ('postpone', 'base', 'mine-conflict',
                             'theirs-conflict', 'mine-full', 'theirs-full',
                             'edit', 'launch')

全局选项:
  --username ARG           : 指定用户名称 ARG
  --password ARG           : 指定密码 ARG
  --no-auth-cache          : 不要缓存用户认证令牌
  --non-interactive        : 不要交互提示
  --trust-server-cert      : 不提示的接受未知的 SSL 服务器证书(只用于选项 “--non-interactive”)
  --config-dir ARG         : 从目录 ARG 读取用户配置文件
  --config-option ARG      : 以下属格式设置用户配置选项：
                                 FILE:SECTION:OPTION=[VALUE]
                             例如：
                                 servers:global:http-library=serf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用操作&lt;br&gt;
1.获取你上次更新之后版本库的修改：&lt;br&gt;
$ svn update&lt;/p&gt;

&lt;p&gt;2.你也可以将工作拷贝更新到旧的修订版本&lt;br&gt;
$ svn update -r30&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Connect 中间件使用解析</title>
   <link href="http://tom.preston-werner.com/2014/12/13/connect-using-the-analytical.html"/>
   <updated>2014-12-13T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2014/12/13/connect-using-the-analytical</id>
   <content type="html">&lt;h3&gt;Connect 介绍&lt;/h3&gt;

&lt;p&gt; Connect是一款高性能、易插拔、开发中间件简单的中间件框架。正是因为这些特点，它在 Node.js 开发框架中是最流行的框架，到目前为止 Connect 有已多达 &lt;a href=&quot;https://github.com/senchalabs/connect/wiki&quot;&gt;200&lt;/a&gt; 个中间件插件。并且著名的 Express 框架的基础架构也是依赖 Connect 中间件&lt;/p&gt;

&lt;p&gt; 有人把 Connect 框架比作层层的过滤网。每个中间件在http处理过程中通过改写request或（和）response的数据、状态，实现了特定的功能。但是我自己认为 Connect 就像一个加工厂，进入某个路由的时候由这个路由所绑定的中间件对路由进行处理和加工，把最后的结果返回出去（出厂）。&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;我使用的版本的 2.9.0&lt;/strong&gt;
 你可以通过 &lt;code&gt;npm install -g connect@2.9.0&lt;/code&gt; 进行安装（这个版本内置了基础的中间件，如果你使用更高版本是没有内置中间件的）&lt;/p&gt;

&lt;h4&gt;写一个简单的 WEB 服务器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var Connect = require('connect'),
    app = Connect();

app.use(function(req, res){
    res.end('Hello World!');
}).listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在访问一下&lt;code&gt;http://localhost:3000/&lt;/code&gt; 页面上显示 Hello World!&lt;/p&gt;

&lt;p&gt;也可以这样创建 WEB 服务器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var Connect = require('connect'),
    app = Connect(),
    http = require('http');

app.use(function(req, res){
    res.end('Hello World Hello Node.js!');
});
http.createServer(app).listen(3000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Connect 处理流程&lt;br&gt;
&lt;img src=&quot;http://182.92.214.162/blog/images/javascript/connect-process.png&quot; alt=&quot;connect处理流程&quot;/&gt;
&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Connect 提供了 WEB 开发的常用基本插件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bodyParser    // 请求内容解析中间件&lt;/li&gt;
&lt;li&gt;multipart     // 文件上传中间件&lt;/li&gt;
&lt;li&gt;cookieParser  // cookie 解析中间件&lt;/li&gt;
&lt;li&gt;session       // session 会话中间件&lt;/li&gt;
&lt;li&gt;static        // 静态文件处理中间件&lt;/li&gt;
&lt;li&gt;vhost         // 虚拟二级域名映射中间件&lt;/li&gt;
&lt;li&gt;favicon       // 网页图标中间件&lt;/li&gt;
&lt;li&gt;等等一些列的中间件&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;对 Connect 源码分析&lt;/h4&gt;

&lt;h5&gt;connect.js&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;/*!
 * Connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Module dependencies.
 */
// 引入必须的模块
var EventEmitter = require('events').EventEmitter
  , proto = require('./proto')
  , utils = require('./utils')
  , path = require('path')
  , basename = path.basename
  , fs = require('fs');

// node patches

require('./patch');

// expose createServer() as the module

exports = module.exports = createServer;

/**
 * Framework version.
 */

exports.version = '2.7.11';

/**
 * Expose mime module.
 */

exports.mime = require('./middleware/static').mime;

/**
 * Expose the prototype.
 */

exports.proto = proto;

/**
 * Auto-load middleware getters.
 */

exports.middleware = {};

/**
 * Expose utilities.
 */

exports.utils = utils;

/**
 * Create a new connect server.
 *
 * @return {Function}
 * @api public
 */
// 创建服务 Connect()
function createServer() {
  // 这个函数会给 http.createServer 使用
  function app(req, res, next){ app.handle(req, res, next); }
  utils.merge(app, proto);    // 继承 proto
  utils.merge(app, EventEmitter.prototype);   // 继承 事件
  app.route = '/';    // 定义默认路由
  app.stack = [];     // 定义处理函数队列
  for (var i = 0; i &amp;lt; arguments.length; ++i) {
    app.use(arguments[i]);
  }
  // 返回 app 函数，可以用他创建 WEB 服务，也能把他传递给 http.createServer(app)
  return app;
};

/**
 * Support old `.createServer()` method.
 */
// 兼容老的版本
createServer.createServer = createServer;

/**
 * Auto-load bundled middleware with getters.
 */
// 加载中间件到 Connect 静态属性中
fs.readdirSync(__dirname + '/middleware').forEach(function(filename){
  if (!/\.js$/.test(filename)) return;
  var name = basename(filename, '.js');
  function load(){ return require('./middleware/' + name); }
  exports.middleware.__defineGetter__(name, load);
  exports.__defineGetter__(name, load);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;proto.js&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;

/*!
 * Connect - HTTPServer
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var http = require('http')
  , utils = require('./utils')
  , debug = require('debug')('connect:dispatcher');

// prototype

var app = module.exports = {};

// environment

var env = process.env.NODE_ENV || 'development';

/**
 * Utilize the given middleware `handle` to the given `route`,
 * defaulting to _/_. This &quot;route&quot; is the mount-point for the
 * middleware, when given a value other than _/_ the middleware
 * is only effective when that segment is present in the request's
 * pathname.
 *
 * For example if we were to mount a function at _/admin_, it would
 * be invoked on _/admin_, and _/admin/settings_, however it would
 * not be invoked for _/_, or _/posts_.
 *
 * Examples:
 *
 *      var app = connect();
 *      app.use(connect.favicon());
 *      app.use(connect.logger());
 *      app.use(connect.static(__dirname + '/public'));
 *
 * If we wanted to prefix static files with _/public_, we could
 * &quot;mount&quot; the `static()` middleware:
 *
 *      app.use('/public', connect.static(__dirname + '/public'));
 *
 * This api is chainable, so the following is valid:
 *
 *      connect()
 *        .use(connect.favicon())
 *        .use(connect.logger())
 *        .use(connect.static(__dirname + '/public'))
 *        .listen(3000);
 *
 * @param {String|Function|Server} route, callback or server
 * @param {Function|Server} callback or server
 * @return {Server} for chaining
 * @api public
 */

app.use = function(route, fn){
  // default route to '/'

  if ('string' != typeof route) {
    fn = route;
    route = '/';
  }

  // wrap sub-apps
  // 如果 handle 是一个 Connect 则包装 Connect
  if ('function' == typeof fn.handle) {
    var server = fn;
    fn.route = route;
    fn = function(req, res, next){
      server.handle(req, res, next);
    };
  }

  // wrap vanilla http.Servers
  if (fn instanceof http.Server) {
    fn = fn.listeners('request')[0];
  }

  // strip trailing slash
  /**
   * 取消末尾斜线
   */
  if ('/' == route[route.length - 1]) {
    route = route.slice(0, -1);
  }

  // add the middleware
  debug('use %s %s', route || '/', fn.name || 'anonymous');
  // 相关路由对应处理函数压入堆中
  this.stack.push({ route: route, handle: fn });

  return this;
};

/**
 * Handle server requests, punting them down
 * the middleware stack.
 *
 * @api private
 */
// 执行路由对应的中间件
app.handle = function(req, res, out) {
  var stack = this.stack
    , fqdn = ~req.url.indexOf('://')
    , removed = ''
    , slashAdded = false
    , index = 0;
  // 切换到下一个中间件
  function next(err) {
    var layer, path, status, c;

    if (slashAdded) {
      req.url = req.url.substr(1);
      slashAdded = false;
    }

    req.url = removed + req.url;
    req.originalUrl = req.originalUrl || req.url;
    removed = '';

    // next callback
    layer = stack[index++];

    // all done
    // 所有 url 对应的路由处理完毕 http 头被发送
    if (!layer || res.headerSent) {
      // delegate to parent
      if (out) return out(err);

      // unhandled error
      // 所有错误处理会在 handle 执行完毕
      if (err) {
        // default to 500
        if (res.statusCode &amp;lt; 400) res.statusCode = 500;
        debug('default %s', res.statusCode);

        // respect err.status
        if (err.status) res.statusCode = err.status;

        // production gets a basic error message
        var msg = 'production' == env
          ? http.STATUS_CODES[res.statusCode]
          : err.stack || err.toString();

        // log to stderr in a non-test env
        if ('test' != env) console.error(err.stack || err.toString());
        if (res.headerSent) return req.socket.destroy();
        res.setHeader('Content-Type', 'text/plain');
        res.setHeader('Content-Length', Buffer.byteLength(msg));
        if ('HEAD' == req.method) return res.end();
        res.end(msg);
      } else {
        // 响应路由未找到，打印404
        debug('default 404');
        res.statusCode = 404;
        res.setHeader('Content-Type', 'text/plain');
        if ('HEAD' == req.method) return res.end();
        res.end('Cannot ' + utils.escape(req.method) + ' ' + utils.escape(req.originalUrl));
      }
      return;
    }

    try {
      path = utils.parseUrl(req).pathname;
      if (undefined == path) path = '/';

      // skip this layer if the route doesn't match.
      // 如果当前访问的 path 和路由不匹配则把错误带入下一个 next 继续执行
      if (0 != path.toLowerCase().indexOf(layer.route.toLowerCase())) return next(err);
      // 同上
      c = path[layer.route.length];
      if (c &amp;amp;&amp;amp; '/' != c &amp;amp;&amp;amp; '.' != c) return next(err);

      // Call the layer handler
      // Trim off the part of the url that matches the route
      // 获取路由外的 url
      removed = layer.route;
      req.url = req.url.substr(removed.length);

      // Ensure leading slash
      // 在 url 后添加 /
      if (!fqdn &amp;amp;&amp;amp; '/' != req.url[0]) {
        req.url = '/' + req.url;
        slashAdded = true;
      }

      debug('%s %s : %s', layer.handle.name || 'anonymous', layer.route, req.originalUrl);
      var arity = layer.handle.length;
      // 根据处理函数的参数数量，传递不同的参数
      if (err) {
        if (arity === 4) {
          layer.handle(err, req, res, next);
        } else {
          next(err);
        }
      } else if (arity &amp;lt; 4) {
        layer.handle(req, res, next);
      } else {
        next();
      }
    } catch (e) {
      next(e);
    }
  }
  next();
};

/**
 * Listen for connections.
 *
 * This method takes the same arguments
 * as node's `http.Server#listen()`.
 *
 * HTTP and HTTPS:
 *
 * If you run your application both as HTTP
 * and HTTPS you may wrap them individually,
 * since your Connect &quot;server&quot; is really just
 * a JavaScript `Function`.
 *
 *      var connect = require('connect')
 *        , http = require('http')
 *        , https = require('https');
 *
 *      var app = connect();
 *
 *      http.createServer(app).listen(80);
 *      https.createServer(options, app).listen(443);
 *
 * @return {http.Server}
 * @api public
 */
// 让 connect 拥有自带创建服务
app.listen = function(){
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的只是对 Connect 进行一个浅析的解剖，如果再要深入的话，需要对 node.js 封装的 http 模块进行解析。如有错误欢迎斧正。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Brackets 10款常用插件</title>
   <link href="http://tom.preston-werner.com/2014/11/23/Brackets-10-common-plug-ins.html"/>
   <updated>2014-11-23T00:00:00+08:00</updated>
   <id>http://tom.preston-werner.com/2014/11/23/Brackets-10-common-plug-ins</id>
   <content type="html">&lt;blockquote&gt;&lt;p&gt;收集常用的一些插件&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;1、显示你打开文件对应的图标 &lt;a href=&quot;https://github.com/ivogabe/Brackets-Icons&quot;&gt;https://github.com/ivogabe/Brackets-Icons&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://182.92.214.162/blog/images/tools/Brackets-Icons.png&quot; alt=&quot;Brackets-Icons&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、javascript 全局变量高亮 &lt;a href=&quot;https://github.com/ForbesLindesay/brackets-globals&quot;&gt;2、javascript 全局变量高亮 https://github.com/ForbesLindesay/brackets-globals&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://182.92.214.162/blog/images/tools/brackets-globals.png&quot; alt=&quot;brackets-globals&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、皮肤插件 &lt;a href=&quot;https://github.com/MiguelCastillo/Brackets-Themes&quot;&gt;https://github.com/MiguelCastillo/Brackets-Themes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、javascript 代码审查，建议所写的代码都检查一下 &lt;a href=&quot;https://github.com/markmcintyre/brackets-jslint&quot;&gt;https://github.com/markmcintyre/brackets-jslint&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5、更改代理，Brackets安装扩展是被墙了，如果用gae，那么这个插件将会很好用 &lt;a href=&quot;https://github.com/ohnnyj/brackets-proxy&quot;&gt;https://github.com/ohnnyj/brackets-proxy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6、emmet 打代码飞起 &lt;a href=&quot;http://emmet.io/&quot;&gt;http://emmet.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7、为你的编辑器增加工作空间管理 &lt;a href=&quot;https://github.com/thomasvalera/Brackets-Workspaces&quot;&gt;https://github.com/thomasvalera/Brackets-Workspaces&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8、代码格式化 &lt;a href=&quot;https://github.com/drewhamlett/brackets-beautify&quot;&gt;https://github.com/drewhamlett/brackets-beautify&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;9、代码备份 &lt;a href=&quot;https://github.com/joemakev/brackets-backup&quot;&gt;https://github.com/joemakev/brackets-backup&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;10、代码快折叠  @See丶桑 同学提供&lt;a href=&quot;https://github.com/thehogfather/brackets-code-folding&quot;&gt;https://github.com/thehogfather/brackets-code-folding&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>